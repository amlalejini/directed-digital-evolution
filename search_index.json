[["index.html", "Supplemental Material for Directed Digital Evolution Project Chapter 1 Introduction 1.1 About this supplemental material 1.2 Contributing authors 1.3 Research overview", " Supplemental Material for Directed Digital Evolution Project Alexander Lalejini, Emily Dolson, Anya E. Vostinar, and Luis Zaman 2022-06-29 Chapter 1 Introduction This is the supplemental material for the preprint, Artificial selection methods from evolutionary computing show promise for directed evolution of microbes. 1.1 About this supplemental material This supplemental material is hosted on GitHub using GitHub pages. This source code and configuration files used to generate this supplemental material can be found in the following repository: https://github.com/amlalejini/directed-digital-evolution. 1.1.1 Contents Our supplemental material includes the following: Software availability (Section 2) Data availability (Section 3) Guide for compiling and running our experiments (Section 4) Supplemental information about the digital organisms used in this work (Section 5) Experiment analyses: Directed digital evolution experiment (Section 7) Aligned individual-level and population-level task directed evolution experiment (Section 8) Varying population maturation period experiment (Section 9) Varied genome lengths experiment (Section 10) Varied sample size for propagating populations (Section 11) 1.2 Contributing authors Alexander Lalejini Emily Dolson Anya E. Vostinar Luis Zaman 1.3 Research overview Abstract: Directed microbial evolution harnesses evolutionary processes in the laboratory to construct microorganisms with enhanced or novel functional traits. Attempting to direct evolutionary processes for applied goals is fundamental to evolutionary computation, which harnesses the principles of Darwinian evolution as a general purpose search engine for solutions to challenging computational problems. Despite their overlapping approaches, artificial selection methods from evolutionary computing are not commonly applied to living systems in the laboratory. In this work, we ask if parent selection algorithmsprocedures for choosing promising progenitorsfrom evolutionary computation might be useful for directing the evolution of microbial populations when selecting for multiple functional traits. To do so, we introduce an agent-based model of directed microbial evolution, which we used to evaluate how well three selection algorithms from evolutionary computing (tournament selection, lexicase selection, and non-dominated elite selection) performed relative to methods commonly used in the laboratory (elite and top-10% selection). We found that multi-objective selection techniques from evolutionary computing (lexicase and non-dominated elite) generally outperformed the commonly used directed evolution approaches when selecting for multiple traits of interest. Our results motivate ongoing work transferring these multi-objective selection procedures into the laboratory. Additionally, our findings suggest that more sophisticated artificial selection methods from evolutionary computation should also be evaluated for use in directed microbial evolution. "],["software-availability.html", "Chapter 2 Software availability", " Chapter 2 Software availability The source code used to implement out experiments as well as the code for performing data analyses and generating visualizations are publicly available on GitHub: https://github.com/amlalejini/directed-digital-evolution. Additionally, our GitHub repository is archived via Zenodo (A. Lalejini et al. 2022). References "],["data-availability.html", "Chapter 3 Data availability", " Chapter 3 Data availability The data produced by the experiments reported in our manuscript are archived and publicly available on the Open Science Framework (A. M. Lalejini 2022) at https://osf.io/zn63x/. References "],["compiling-and-running-our-experiments.html", "Chapter 4 Compiling and running our experiments 4.1 Manual 4.2 Docker", " Chapter 4 Compiling and running our experiments Here, we provide a brief guide to compiling and running our experiments. Please file an issue if something is unclear or does not work. We document two methods of compiling and running our experiments: Manually downloading the repository and dependencies, compiling, and running on your local machine Running inside of a Docker container 4.1 Manual These instructions assume a Ubuntu-flavored Linux operating system, and they should mostly work for MacOS too (but no promises there). Otherwise, we recommend using our Docker image or using a virtual machine running linux. You will need a C++ compiler capable of compiling C++17 code. For example, Im using: g++ (Ubuntu 11.2.0-7ubuntu2) 11.2.0 Next, clone this repository from GitHub. git clone https://github.com/amlalejini/directed-digital-evolution After cloning, cd into the freshly cloned repository, and run git submodule update --init --recursive This should download all of the third-party dependencies (into the third-party/ directory) necessary for compiling our experiment software. From here, you should be able to compile the experiment source code by running make in the root directory of the repository. Edit the PROJECT, MAIN_CPP, and THREADING variables at the top of the Makefile to configure which experiment youre compiling and whether you compile with threading (note some data tracking will not work with threading enabled). The configuration files used for each experiment can be found inside the particular experiments associated directory (experiments/[experiment-name]/hpcc/config/). 4.2 Docker You can use the Dockerfile in our repository to build a docker image locally, or you can pull the latest docker image from this DockerHub repository: amlalejini/directed-digital-evolution. To pull the latest docker image from DockerHub, run docker pull amlalejini/directed-digital-evolution Regardless of whether you built the image locally or pulled it from DockerHub, it should contain: all of the requisite dependencies to run our experiment software and analysis scripts all of our project source code (from our GitHub repository) To run the container interactively: docker run -it --entrypoint bash amlalejini/directed-digital-evolution "],["digital-organisms.html", "Chapter 5 Digital Organisms 5.1 Virtual Hardware Components 5.2 Instruction set 5.3 Ancestral genomes", " Chapter 5 Digital Organisms Here, we provide supplemental information about the digital organisms used in our experiments. 5.1 Virtual Hardware Components Each digital organism is defined by a sequence of program instructions (its genome) and a set of virtual hardware components used to interpret and express those instructions. The virtual hardware and genetic representation used in this work extends that of (Dolson, Lalejini, and Ofria 2019,hernandez_what_2022). The virtual hardware includes the following components: Instruction pointer: A marker that indicates the position in the genome currently being executed. Instructions may influence how the instruction pointer moves through the genome (e.g., if instructions). Memory registers: A digital organism has access to 16 memory registers (abbreviated as REG-0 through REG-15) for performing computations. Each register can store a single floating point value, and instructions can read and write to registers. Registers are initialized with values corresponding to their register ID (e.g., REG-0 is initialized with the value 0). Memory stacks: Each digital organism has access to 16 memory stacks (abbreviated as STK-0 through STK-15). Instructions can push values onto a stack and pop them off later. Input and output buffers: Each digital organism has a read-only input buffer and a write-only output buffer. Digital organisms could execute instructions to read values from their input buffer and execute instructions to write values to their output buffer. When an organism is born, their output buffer is empty, and we initialize their input buffer with 2 values (as all computational tasks used in this work had a maximum of 2 inputs), each value ranging between 0 and 100000000. Input buffers are accessed in order and are circular; that is, when an instruction reads from the input buffer, it reads the next value (starting with the first) and wraps around to the beginning after reading the last value in the buffer. To perform a computational task (e.g., those in Table 1 of our manuscript), an organism must load values from their input buffer into their memory registers, compute the requisite function, and output the result to their output buffer. During an organisms lifetime, we analyzed their output buffer to determine if they performed any of the designated computational tasks. Scopes: Each digital organism could make use of 16 `scopes'' plus a global scope, making 17 possible scopes. Below is an introduction to scopes as a mechanism for modularity, which is adapted from [@dolson_exploring_2019]: &gt; In software development, the _scope_ of a variable specifies the region of code in which that element may be used. In a sense, a scope is like a programmatic membrane, capable of encapsulating programmatic elements (e.g., variables, functions, _et cetera_) and allowing regions to be looped through or skipped entirely. Our genetic representation gives programs control over instruction- and memory-scoping, which allows programs to manage flow control and variable lifetime. &gt; &gt; In our genetic representation, scopes provide the backbone on top of which all of the other modularity-promoting features, such as loops and functions, are built. All instructions in a program exist within a scope, be it the default outermost scope or one of the 16 other available scopes that can be accessed via instructions. The 16 inner scopes have a hierarchy to them, such that higher-numbered scopes are always nested inside lower-numbered scopes. &gt; &gt; Starting at the beginning of a program, all instructions before the first change of scope are in the outermost (global) scope. After a scope-changing instruction occurs in the program, subsequent instructions are added to the new scope until another scope-changing instruction is encountered, and so on. These scopes are ordered numerically. Higher-numbered scopes are always nested inside lower-numbered scopes. Scopes can be exited with thebreakinstruction or by any instruction that moves control to a lower-numbered scope. &gt; &gt; Scopes are also the foundation of program modules (functions) in our genetic representation. Thedefineinstruction allows the program to put instructions into a scope and associate the contents of that scope with one of 16 possible function names. Later, if that function is called (using thecall` instruction), the program enters the scope in which that function was defined and executes the instructions within that scope in sequence, including any internal (nested) scopes. &gt; &gt; Similarly, scopes are the foundation of loops. Two kinds of loops exist in the instruction set used here: while loops and countdown loops. Loops of both types have a corresponding scope, which contains the sequence of instructions that make up the body of the loop. Both types of loops repeat their body (i.e., the contents of their associated scope) until the value in an argument-specified register is 0. Countdown loops automatically decrement this register by one on every iteration. When any instruction is encountered that would cause the program to leave the current scope, the current iteration is ended and the next one begins. Self-replication machinery: A digital organisms virtual hardware tracks how many instructions an organism has copied (regardless of how many of those copies are erroneous), and prevents an organism from dividing until it has copied at least as many instructions as are in its genome. 5.2 Instruction set The table below gives the instruction set used by digital organisms in our digital directed evolution experiments. Note that each instruction in an organisms genome contains three arguments, which may modify the effect of the instruction. Instruction arguments are limited to the values 0 through 15, and arguments are used to specify any of the following: registers, raw values, or scopes. In an instructions description, we denote argument values as ARG-0, ARG-1, and ARG-2 where ARG-0 represents the value of the first argument for the instruction and so on. Instructions that operate on bitstrings (e.g., Not and Nand) operate on the underlying bit representation of the values stored in the relevant registers. When the result of a binary (true/false) comparison is stored in a register (e.g., from a TestEqu instruction), false is stored as 0 and true is stored as 1. We excluded the following instructions from our genetic programming experiment: CopyInst, DivideSelf. Instruction # Arguments New scope Description Nop 0 None No operation Inc 1 None REG[ARG-0] = REG[ARG-0] + 1 Dec 1 None REG[ARG-0] = REG[ARG-0] - 1 Not 1 None REG[ARG-0] = !REG[ARG-0] SetReg 2 None REG[ARG-0] = ARG-1 Add 3 None REG[ARG-2] = REG[ARG-0] + REG[ARG-1] Sub 3 None REG[ARG-2] = REG[ARG-0] - REG[ARG-1] Mult 3 None REG[ARG-2] = REG[ARG-0] * REG[ARG-1] Div 3 None REG[ARG-2] = REG[ARG-0] / REG[ARG-1] Mod 3 None REG[ARG-2] = REG[ARG-0] % REG[ARG-1] Nand 3 None REG[ARG-2] = !REG[ARG-0] &amp; REG[ARG-1] TestEqu 3 None REG[ARG-2] = REG[ARG-0] == REG[ARG-1] TestNEqu 3 None REG[ARG-2] = REG[ARG-0] != REG[ARG-1] TestLess 3 None REG[ARG-2] = REG[ARG-0] \\(&lt;\\) REG[ARG-1] If 2 ARG-1 If REG[ARG-0] != 0, continue to SCOPE[ARG-1]; else, skip SCOPE[ARG-1] While 2 ARG-1 Repeat the contents of SCOPE[ARG-1] until REG[ARG-0] equals 0 Countdown 2 ARG-1 Repeat the contents of SCOPE[ARG-1], decrementing REG[ARG-0] each time, until REG[ARG-0] equals 0 Break 1 None Break out of SCOPE[ARG-0] Scope 1 ARG-0 Enter SCOPE[ARG-0] Define 2 ARG-1 Define this position as the starting point of function ARG-0 with its contents defined as SCOPE[ARG-1]. The function body is skipped after being defined; when called, the function automatically returns when SCOPE[ARG-1] is exited. Call 1 None Call function ARG-0, which must already have been defined by a instruction. Push 2 None Push REG[ARG-0] onto STK[ARG-1] Pop 2 None Pop top value of STK[ARG-0] onto REG[ARG-1] CopyVal 2 None REG[ARG-1] = REG[ARG-0] ScopeReg 1 None Backup the value in REG[ARG-0]. When the current scope is exited, it will be restored. CopyInst 0 None Copy the next instruction (for self-replication). GetLen 1 None Set REG[ARG-0] to the current genome length. DivideSelf 0 None If the requisite number of instructions have been copied, trigger division (producing an offspring). Input 1 None Load the next input value into REG[ARG-0] Output 1 None Append REG[ARG-0] to the output buffer 5.3 Ancestral genomes The files containing the ancestral genome used to seed initial populations for each experiment are included in the GitHub repository (A. Lalejini et al. 2022). Each ancestral genome is 100 instructions long. The ancestral genome used for our genetic programming experiments does nothing except define a root scope. The ancestral genome used for our directed evolution experiments copies itself and then divides, producing an offspring. 5.3.1 Ancestral genome for genetic programming experiment Scope 0 Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop 5.3.2 Ancestral genome for directed evolution experiments Scope 0 Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop Nop GetLen 15 Countdown 15 1 CopyInst 0 Scope 0 DivideSelf References "],["conventional-genetic-programming-experiment.html", "Chapter 6 Conventional genetic programming experiment 6.1 Overview 6.2 Analysis dependencies 6.3 Setup 6.4 Number of successful replicates 6.5 Final task coverage 6.6 Generation 2,000 task coverage 6.7 Population-level task coverage 6.8 Generations elapsed before a solution evolves 6.9 Best task coverage over time 6.10 Manuscript Figure", " Chapter 6 Conventional genetic programming experiment Data analyses for our conventional evolutionary computing experiment. 6.1 Overview experiment_slug &lt;- &quot;2021-11-15-ec&quot; working_directory &lt;- paste0(&quot;experiments/&quot;,experiment_slug,&quot;/analysis/&quot;) 6.2 Analysis dependencies Load all required R libraries library(tidyverse) ## -- Attaching packages --------------------------------------- tidyverse 1.3.1 -- ## v ggplot2 3.3.6 v purrr 0.3.4 ## v tibble 3.1.7 v dplyr 1.0.9 ## v tidyr 1.2.0 v stringr 1.4.0 ## v readr 2.1.2 v forcats 0.5.1 ## -- Conflicts ------------------------------------------ tidyverse_conflicts() -- ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() library(ggplot2) library(cowplot) library(RColorBrewer) library(khroma) source(&quot;https://gist.githubusercontent.com/benmarwick/2a1bb0133ff568cbe28d/raw/fb53bd97121f7f9ce947837ef1a4c65a73bffb3f/geom_flat_violin.R&quot;) These analyses were knit with the following environment: print(version) ## _ ## platform x86_64-pc-linux-gnu ## arch x86_64 ## os linux-gnu ## system x86_64, linux-gnu ## status ## major 4 ## minor 2.1 ## year 2022 ## month 06 ## day 23 ## svn rev 82513 ## language R ## version.string R version 4.2.1 (2022-06-23) ## nickname Funny-Looking Kid 6.3 Setup Load experiment summary data. exp_summary_data_loc &lt;- paste0(working_directory,&quot;data/experiment_summary.csv&quot;) exp_summary_data &lt;- read.csv(exp_summary_data_loc, na.strings=&quot;NONE&quot;) exp_summary_data$SELECTION_METHOD &lt;- factor( exp_summary_data$SELECTION_METHOD, levels=c( &quot;elite&quot;, &quot;elite-10&quot;, &quot;tournament&quot;, &quot;lexicase&quot;, &quot;non-dominated-elite&quot;, &quot;non-dominated-tournament&quot;, &quot;random&quot;, &quot;none&quot; ), labels=c( &quot;elite&quot;, &quot;elite-10&quot;, &quot;tourn&quot;, &quot;lex&quot;, &quot;nde&quot;, &quot;ndt&quot;, &quot;random&quot;, &quot;none&quot; ) ) Load time series data. time_series_data_loc &lt;- paste0(working_directory,&quot;data/pop_snapshot_time_series_corrected.csv&quot;) time_series_data &lt;- read.csv(time_series_data_loc, na.strings=&quot;NONE&quot;) get_sel &lt;- function(seed) { return(filter(exp_summary_data, SEED==seed)$SELECTION_METHOD) } solution_evolved_fun &lt;- function(seed, update) { d &lt;- filter(exp_summary_data, SEED==seed) return(update==d$update &amp;&amp; d$max_fit_is_solution==&quot;1&quot;); } time_series_data$SELECTION_METHOD &lt;- mapply( get_sel, time_series_data$SEED ) time_series_data$solution_evolved &lt;- mapply( solution_evolved_fun, time_series_data$SEED, time_series_data$update ) time_series_data$SELECTION_METHOD &lt;- as.factor( time_series_data$SELECTION_METHOD ) exp_data_gen_2000 &lt;- filter(time_series_data, update==2000) Miscellaneous setup. # Configure our default graphing theme theme_set(theme_cowplot()) # Palette scale_fill_fun &lt;- scale_fill_bright scale_color_fun &lt;- scale_color_bright # Create a directory to store plots plot_directory &lt;- paste0(working_directory, &quot;plots/&quot;) dir.create(plot_directory, showWarnings=FALSE) # Order selection schemes. selection_method_breaks &lt;- c(&quot;elite&quot;, &quot;elite-10&quot;, &quot;tourn&quot;, &quot;lex&quot;, &quot;nde&quot;, &quot;random&quot;, &quot;none&quot;) selection_method_labels &lt;- c(&quot;ELITE&quot;, &quot;TOP-10&quot;, &quot;TOURN&quot;, &quot;LEX&quot;, &quot;NDE&quot;, &quot;RAND&quot;, &quot;NONE&quot;) 6.4 Number of successful replicates We considered a run to be successful if it produced a program capable of performing all 22 tasks during evaluation. ggplot( filter(exp_summary_data, max_fit_is_solution==&quot;1&quot;), aes(x=SELECTION_METHOD, fill=SELECTION_METHOD) ) + geom_bar() + geom_text( stat=&quot;count&quot;, mapping=aes(label=..count..), position=position_dodge(0.9), vjust=0 ) + scale_y_continuous( limits=c(0, 50), breaks=seq(0,50,10) ) + scale_x_discrete( name=&quot;Selection Method&quot;, limits=selection_method_breaks, breaks=selection_method_breaks, labels=selection_method_labels ) + scale_fill_fun( limits=selection_method_breaks, breaks=selection_method_breaks, labels=selection_method_labels ) + scale_color_fun( limits=selection_method_breaks, breaks=selection_method_breaks, labels=selection_method_labels ) + ylab(&quot;Successful replicates&quot;) + theme(legend.position = &quot;none&quot;) ggsave( paste0(plot_directory, &quot;2021-11-15-num-solutions.pdf&quot;) ) ## Saving 7 x 5 in image 6.5 Final task coverage Task coverage after 55,000 generations of evolution. max_task_cov_fig &lt;- ggplot( exp_summary_data, aes( x=SELECTION_METHOD, y=max_fit_aggregate_score, fill=SELECTION_METHOD ) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8, adjust=1.5 ) + geom_point( mapping=aes(color=SELECTION_METHOD), position = position_jitter(width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_y_continuous( name=&quot;Task Coverage&quot;, limits=c(-0.5,22.5), breaks=seq(0,22,2) ) + scale_x_discrete( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + scale_fill_fun( ) + scale_color_fun( ) + theme( legend.position=&quot;none&quot; # axis.text = element_text(size = 8), # axis.title = element_text(size=10) ) max_task_cov_fig ggsave( plot=max_task_cov_fig, filename=paste0(plot_directory, &quot;2021-11-15-ec-performance.pdf&quot;), height=3, width=4 ) Statistical results: kruskal.test( formula=max_fit_aggregate_score~SELECTION_METHOD, data=exp_summary_data ) ## ## Kruskal-Wallis rank sum test ## ## data: max_fit_aggregate_score by SELECTION_METHOD ## Kruskal-Wallis chi-squared = 332.52, df = 6, p-value &lt; 2.2e-16 # Kruskal-wallis is significant, so we do a post-hoc wilcoxon rank-sum. pairwise.wilcox.test( x=exp_summary_data$max_fit_aggregate_score, g=exp_summary_data$SELECTION_METHOD, p.adjust.method=&quot;bonferroni&quot;, ) ## ## Pairwise comparisons using Wilcoxon rank sum test with continuity correction ## ## data: exp_summary_data$max_fit_aggregate_score and exp_summary_data$SELECTION_METHOD ## ## elite elite-10 tourn lex nde random ## elite-10 0.0087 - - - - - ## tourn 1.8e-14 &lt; 2e-16 - - - - ## lex &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 - - - ## nde &lt; 2e-16 &lt; 2e-16 1.7e-15 &lt; 2e-16 - - ## random &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 - ## none &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 0.8360 ## ## P value adjustment method: bonferroni 6.6 Generation 2,000 task coverage Task coverage after 2,000 generations (i.e., the number of cycles runin the directed evolution experiments) ggplot( exp_data_gen_2000, aes( x=SELECTION_METHOD, y=max_org_task_coverage, fill=SELECTION_METHOD ) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8, adjust=1.5 ) + geom_point( mapping=aes(color=SELECTION_METHOD), position = position_jitter(width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_y_continuous( name=&quot;Task Coverage&quot;, limits=c(-0.5,22.5), breaks=seq(0,22,2) ) + scale_x_discrete( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + scale_fill_fun() + scale_color_fun() + theme( legend.position=&quot;none&quot;, axis.text = element_text(size = 8), axis.title = element_text(size=10) ) ggsave( filename=paste0(plot_directory, &quot;max_aggregate_score_gen_2000.pdf&quot;), height=3, width=4 ) Statistical results: kruskal.test( formula=max_org_task_coverage~SELECTION_METHOD, data=exp_data_gen_2000 ) ## ## Kruskal-Wallis rank sum test ## ## data: max_org_task_coverage by SELECTION_METHOD ## Kruskal-Wallis chi-squared = 322.54, df = 6, p-value &lt; 2.2e-16 # Kruskal-wallis is significant, so we do a post-hoc wilcoxon rank-sum. pairwise.wilcox.test( x=exp_data_gen_2000$max_org_task_coverage, g=exp_data_gen_2000$SELECTION_METHOD, p.adjust.method=&quot;bonferroni&quot;, ) ## ## Pairwise comparisons using Wilcoxon rank sum test with continuity correction ## ## data: exp_data_gen_2000$max_org_task_coverage and exp_data_gen_2000$SELECTION_METHOD ## ## elite elite-10 tourn lex nde random ## elite-10 1.4e-09 - - - - - ## tourn 0.0013 1.9e-14 - - - - ## lex &lt; 2e-16 7.3e-15 &lt; 2e-16 - - - ## nde 9.8e-14 2.3e-16 2.7e-11 &lt; 2e-16 - - ## random &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 - ## none &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 1.0000 ## ## P value adjustment method: bonferroni 6.7 Population-level task coverage Task coverage across entire population after 55,000 generations of evolution. ggplot( exp_summary_data, aes( x=SELECTION_METHOD, y=population_num_tasks_covered, fill=SELECTION_METHOD ) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8 ) + geom_point( mapping=aes(color=SELECTION_METHOD), position = position_jitter(width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_fill_fun() + scale_color_fun() + theme( legend.position=&quot;none&quot; ) ggsave( paste0(plot_directory, &quot;population_num_tasks_covered.pdf&quot;) ) ## Saving 7 x 5 in image 6.8 Generations elapsed before a solution evolves Runs where no solution evolved are in gray and plotted as unsolved. unfinished_data &lt;- filter(exp_summary_data, max_fit_is_solution==&quot;0&quot;) unfinished_data$graph_update &lt;- 60000 ggplot( filter(exp_summary_data, max_fit_is_solution==&quot;1&quot;), aes( x=SELECTION_METHOD, y=update ) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8 ) + geom_point( position = position_jitter(width = .15), size = .5, alpha = 0.8 ) + geom_point( data = unfinished_data, mapping=aes( x=SELECTION_METHOD, y=graph_update ), color=&quot;gray&quot;, position = position_jitter(width = .15, height=1000), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_y_continuous( name=&quot;Generation first solution evolved&quot;, limits=c(0, 65000), breaks=c(0, 10000, 20000, 30000, 40000, 50000, 60000), labels=c(&quot;0&quot;, &quot;10000&quot;, &quot;20000&quot;, &quot;30000&quot;, &quot;40000&quot;, &quot;50000&quot;, &quot;Unsolved&quot;) ) + theme( legend.position=&quot;none&quot; ) ## Warning: Groups with fewer than two data points have been dropped. ggsave( paste0(plot_directory, &quot;updates_until_solution.pdf&quot;) ) ## Saving 7 x 5 in image ## Warning: Groups with fewer than two data points have been dropped. 6.9 Best task coverage over time max_task_cov_ts &lt;- ggplot( time_series_data, aes( x=update, y=max_org_task_coverage, fill=SELECTION_METHOD, color=SELECTION_METHOD ) ) + stat_summary(geom=&quot;line&quot;, fun=mean) + stat_summary( geom=&quot;ribbon&quot;, fun.data=&quot;mean_cl_boot&quot;, fun.args=list(conf.int=0.95), alpha=0.2, linetype=0 ) + scale_y_continuous( name=&quot;Task Coverage&quot;, limits=c(-0.5,22.5), breaks=seq(0,22,2) ) + scale_x_continuous( name=&quot;Generation&quot;, limits=c(0, 55000), breaks=c(0, 10000, 20000, 30000, 40000, 50000) ) + scale_fill_fun( name=&quot;Selection method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + scale_color_fun( name=&quot;Selection method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + theme( legend.position=&quot;none&quot; ) max_task_cov_ts ## Warning: Computation failed in `stat_summary()`: ggsave( paste0(plot_directory, &quot;2021-11-15-ec-performance-ts.pdf&quot;) ) ## Saving 7 x 5 in image ## Warning: Computation failed in `stat_summary()`: 6.10 Manuscript Figure legend &lt;- cowplot::get_legend( max_task_cov_ts + guides( color=guide_legend(nrow=1), fill=guide_legend(nrow=1) ) + theme( legend.position = &quot;bottom&quot;, legend.box=&quot;horizontal&quot;, legend.justification=&quot;center&quot; ) ) ## Warning: Computation failed in `stat_summary()`: grid &lt;- plot_grid( max_task_cov_ts + ggtitle(&quot;Task coverage over time&quot;) + labs(subtitle=&quot;&quot;) + theme(legend.position=&quot;none&quot;), max_task_cov_fig + ggtitle(&quot;Final task coverage&quot;) + theme(), nrow=1, ncol=2, align=&quot;h&quot;, # rel_widths=c(3,2), labels=&quot;auto&quot; ) ## Warning: Computation failed in `stat_summary()`: # grid grid &lt;- plot_grid( grid, legend, nrow=2, ncol=1, rel_heights=c(1, 0.1) ) grid save_plot( paste( plot_directory, &quot;2021-11-15-performance-fig.pdf&quot;, sep=&quot;&quot; ), grid, base_width=12, base_height=6 ) "],["directed-digital-evolution-experiment.html", "Chapter 7 Directed digital evolution experiment 7.1 Overview 7.2 Analysis dependencies 7.3 Setup 7.4 Best single-population task coverage 7.5 Metapopulation task coverage 7.6 Metapopulation task profile diversity 7.7 Task coverage per N populations 7.8 Average number of different populations selected per generation 7.9 Average number of organisms in populations at end of maturation period 7.10 Average generations per maturation period 7.11 Representative task profiles 7.12 Manuscript figures", " Chapter 7 Directed digital evolution experiment Supplemental information and data analyses for the initial (baseline) directed evolution modeling experiment. 7.1 Overview experiment_slug &lt;- &quot;2021-11-11-selection&quot; working_directory &lt;- paste0(&quot;experiments/&quot;,experiment_slug,&quot;/analysis/&quot;) 7.2 Analysis dependencies Load all required R libraries library(tidyverse) library(ggplot2) library(cowplot) library(RColorBrewer) library(khroma) source(&quot;https://gist.githubusercontent.com/benmarwick/2a1bb0133ff568cbe28d/raw/fb53bd97121f7f9ce947837ef1a4c65a73bffb3f/geom_flat_violin.R&quot;) These analyses were knit with the following environment: print(version) ## _ ## platform x86_64-pc-linux-gnu ## arch x86_64 ## os linux-gnu ## system x86_64, linux-gnu ## status ## major 4 ## minor 2.1 ## year 2022 ## month 06 ## day 23 ## svn rev 82513 ## language R ## version.string R version 4.2.1 (2022-06-23) ## nickname Funny-Looking Kid 7.3 Setup Load experiment summary data. exp_summary_data_loc &lt;- paste0(working_directory,&quot;data/experiment_summary.csv&quot;) exp_summary_data &lt;- read.csv(exp_summary_data_loc, na.strings=&quot;NONE&quot;) exp_summary_data$SELECTION_METHOD &lt;- factor( exp_summary_data$SELECTION_METHOD, levels=c( &quot;elite&quot;, &quot;elite-10&quot;, &quot;tournament&quot;, &quot;lexicase&quot;, &quot;non-dominated-elite&quot;, &quot;random&quot;, &quot;none&quot; ), labels=c( &quot;elite&quot;, &quot;elite-10&quot;, &quot;tourn&quot;, &quot;lex&quot;, &quot;nde&quot;, &quot;random&quot;, &quot;none&quot; ) ) Load time series data. times_series_data_loc &lt;- paste0(working_directory,&quot;data/evaluation_time_series_corrected.csv&quot;) times_series_data &lt;- read.csv(times_series_data_loc, na.strings=&quot;NONE&quot;) # Specify experimental condition for each datum. times_series_data$SELECTION_METHOD &lt;- factor( times_series_data$SELECTION_METHOD, levels=c( &quot;elite&quot;, &quot;elite-10&quot;, &quot;tournament&quot;, &quot;lexicase&quot;, &quot;non-dominated-elite&quot;, &quot;non-dominated-tournament&quot;, &quot;random&quot;, &quot;none&quot; ), labels=c( &quot;elite&quot;, &quot;elite-10&quot;, &quot;tourn&quot;, &quot;lex&quot;, &quot;nde&quot;, &quot;ndt&quot;, &quot;random&quot;, &quot;none&quot; ) ) times_series_data$epoch_offset &lt;- times_series_data$epoch+1 Load task coverage per population data. task_coverage_per_pop_data_loc &lt;- paste0(working_directory,&quot;data/max_coverage_per_pop_cnt.csv&quot;) task_coverage_per_pop_data &lt;- read.csv(task_coverage_per_pop_data_loc, na.strings=&quot;NONE&quot;) # Specify experimental condition for each datum. task_coverage_per_pop_data$SELECTION_METHOD &lt;- factor( task_coverage_per_pop_data$SELECTION_METHOD, levels=c( &quot;elite&quot;, &quot;elite-10&quot;, &quot;tournament&quot;, &quot;lexicase&quot;, &quot;non-dominated-elite&quot;, &quot;non-dominated-tournament&quot;, &quot;random&quot;, &quot;none&quot; ), labels=c( &quot;elite&quot;, &quot;elite-10&quot;, &quot;tourn&quot;, &quot;lex&quot;, &quot;nde&quot;, &quot;ndt&quot;, &quot;random&quot;, &quot;none&quot; ) ) Miscellaneous setup # Configure our default graphing theme theme_set(theme_cowplot()) # Palette scale_fill_fun &lt;- scale_fill_bright scale_color_fun &lt;- scale_color_bright alpha &lt;- 0.05 # Create a directory to store plots plot_directory &lt;- paste0(working_directory, &quot;plots/&quot;) dir.create(plot_directory, showWarnings=FALSE) p_label &lt;- function(p_value) { threshold = 0.0001 if (p_value &lt; threshold) { return(paste0(&quot;p &lt; &quot;, threshold)) } else { return(paste0(&quot;p = &quot;, p_value)) } } selection_method_breaks &lt;- c(&quot;elite&quot;, &quot;elite-10&quot;, &quot;tourn&quot;, &quot;lex&quot;, &quot;nde&quot;, &quot;random&quot;, &quot;none&quot;) selection_method_labels &lt;- c(&quot;ELITE&quot;, &quot;TOP-10&quot;, &quot;TOURN&quot;, &quot;LEX&quot;, &quot;NDE&quot;, &quot;RAND&quot;, &quot;NONE&quot;) 7.4 Best single-population task coverage Best single-population task coverage at the end of the experiment. max_trait_cov_fig &lt;- ggplot( exp_summary_data, aes( x=SELECTION_METHOD, y=max_trait_coverage, fill=SELECTION_METHOD ) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8, adjust=1.5 ) + geom_point( mapping=aes(color=SELECTION_METHOD), position = position_jitter(height=0.1, width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_y_continuous( name=&quot;Task Coverage&quot;, limits=c(-0.5,18.5), breaks=seq(0,18,2) ) + scale_x_discrete( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + scale_fill_fun() + scale_color_fun() + theme( legend.position=&quot;none&quot; ) max_trait_cov_fig ggsave( plot=max_trait_cov_fig, paste0(plot_directory, &quot;max_trait_coverage.pdf&quot;) ) ## Saving 7 x 5 in image Statistical results: kruskal.test( formula=max_trait_coverage~SELECTION_METHOD, data=exp_summary_data ) ## ## Kruskal-Wallis rank sum test ## ## data: max_trait_coverage by SELECTION_METHOD ## Kruskal-Wallis chi-squared = 244.55, df = 6, p-value &lt; 2.2e-16 # Kruskal-wallis is significant, so we do a post-hoc wilcoxon rank-sum. pairwise.wilcox.test( x=exp_summary_data$max_trait_coverage, g=exp_summary_data$SELECTION_METHOD, p.adjust.method=&quot;bonferroni&quot;, ) ## ## Pairwise comparisons using Wilcoxon rank sum test with continuity correction ## ## data: exp_summary_data$max_trait_coverage and exp_summary_data$SELECTION_METHOD ## ## elite elite-10 tourn lex nde random ## elite-10 1.0000 - - - - - ## tourn 0.0404 0.0167 - - - - ## lex 2.3e-11 9.6e-10 3.2e-14 - - - ## nde 0.0001 0.0234 6.8e-10 2.2e-07 - - ## random 1.2e-14 6.2e-13 1.7e-10 &lt; 2e-16 &lt; 2e-16 - ## none 1.0e-14 4.8e-12 1.1e-08 &lt; 2e-16 &lt; 2e-16 0.0392 ## ## P value adjustment method: bonferroni 7.4.1 Best single-population task coverage time series To speed up graphing, we plot a low-resolution version of the time series. max_trait_cov_ot_fig &lt;- ggplot( # times_series_data, filter(times_series_data, (epoch_offset%%100)==0 | epoch_offset==1), aes( x=epoch_offset, y=max_trait_coverage, fill=SELECTION_METHOD, color=SELECTION_METHOD ) ) + stat_summary(geom=&quot;line&quot;, fun=mean) + stat_summary( geom=&quot;ribbon&quot;, fun.data=&quot;mean_cl_boot&quot;, fun.args=list(conf.int=0.95), alpha=0.2, linetype=0 ) + scale_x_continuous( name=&quot;Cycles&quot; ) + scale_y_continuous( name=&quot;Task Coverage&quot;, limits=c(-0.5,18.5), breaks=seq(0,18,2) ) + scale_fill_fun( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + scale_color_fun( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + theme( legend.position=&quot;none&quot; ) max_trait_cov_ot_fig ## Warning: Computation failed in `stat_summary()`: ggsave( plot=max_trait_cov_ot_fig, filename=paste0(plot_directory, &quot;2021-11-11-best-pop-task-cov-ts.pdf&quot;), width=10, height=6 ) ## Warning: Computation failed in `stat_summary()`: 7.4.1.1 First 30 cycles of the experiment max_trait_cov_ot_early_fig &lt;- ggplot( # times_series_data, filter(times_series_data, (epoch_offset &lt;= 30)), aes( x=epoch_offset, y=max_trait_coverage, fill=SELECTION_METHOD, color=SELECTION_METHOD ) ) + stat_summary(geom=&quot;line&quot;, fun=mean) + stat_summary( geom=&quot;ribbon&quot;, fun.data=&quot;mean_cl_boot&quot;, fun.args=list(conf.int=0.95), alpha=0.2, linetype=0 ) + scale_x_continuous( name=&quot;Cycles&quot; ) + scale_y_continuous( name=&quot;Task Coverage&quot;, limits=c(-0.5,18.5), breaks=seq(0,18,2) ) + scale_fill_fun( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + scale_color_fun( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + theme( legend.position=&quot;bottom&quot; ) max_trait_cov_ot_early_fig ## Warning: Computation failed in `stat_summary()`: ggsave( filename=paste0(plot_directory, &quot;2021-11-11-best-pop-task-cov-ts-early.pdf&quot;), width=10, height=6 ) ## Warning: Computation failed in `stat_summary()`: After just 10 cycles, we observed significant gains from using NDE and LEX selection protocols. early_data &lt;- filter(times_series_data, epoch_offset==10) kruskal.test( formula=max_trait_coverage~SELECTION_METHOD, data=early_data ) ## ## Kruskal-Wallis rank sum test ## ## data: max_trait_coverage by SELECTION_METHOD ## Kruskal-Wallis chi-squared = 166.2, df = 6, p-value &lt; 2.2e-16 # Kruskal-wallis is significant, so we do a post-hoc wilcoxon rank-sum. pairwise.wilcox.test( x=early_data$max_trait_coverage, g=early_data$SELECTION_METHOD, p.adjust.method=&quot;bonferroni&quot;, ) ## ## Pairwise comparisons using Wilcoxon rank sum test with continuity correction ## ## data: early_data$max_trait_coverage and early_data$SELECTION_METHOD ## ## elite elite-10 tourn lex nde random ## elite-10 1.00000 - - - - - ## tourn 1.00000 1.00000 - - - - ## lex 2.1e-06 0.00087 2.3e-06 - - - ## nde 0.14106 1.00000 0.63684 0.00709 - - ## random 3.3e-07 5.5e-10 5.2e-11 1.2e-13 1.7e-11 - ## none 2.0e-06 3.2e-09 3.9e-10 3.6e-13 9.5e-11 1.00000 ## ## P value adjustment method: bonferroni 7.5 Metapopulation task coverage Metapopulation task coverage at the end of the experiment. total_trait_cov_fig &lt;- ggplot( exp_summary_data, aes( x=SELECTION_METHOD, y=total_trait_coverage, fill=SELECTION_METHOD ) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8, adjust=1.5 ) + geom_point( mapping=aes(color=SELECTION_METHOD), position = position_jitter(height=0.1, width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_y_continuous( name=&quot;Task Coverage&quot;, limits=c(-0.5,18.5), breaks=seq(0,18,2) ) + scale_x_discrete( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + scale_fill_fun( ) + scale_color_fun( ) + theme( legend.position=&quot;none&quot; ) total_trait_cov_fig ggsave( plot=total_trait_cov_fig, paste0(plot_directory, &quot;2021-11-11-metapop-task-cov.pdf&quot;) ) ## Saving 7 x 5 in image Statistical results: kruskal.test( formula=total_trait_coverage~SELECTION_METHOD, data=exp_summary_data ) ## ## Kruskal-Wallis rank sum test ## ## data: total_trait_coverage by SELECTION_METHOD ## Kruskal-Wallis chi-squared = 244.66, df = 6, p-value &lt; 2.2e-16 # Kruskal-wallis is significant, so we do a post-hoc wilcoxon rank-sum. pairwise.wilcox.test( x=exp_summary_data$total_trait_coverage, g=exp_summary_data$SELECTION_METHOD, p.adjust.method=&quot;bonferroni&quot;, ) ## ## Pairwise comparisons using Wilcoxon rank sum test with continuity correction ## ## data: exp_summary_data$total_trait_coverage and exp_summary_data$SELECTION_METHOD ## ## elite elite-10 tourn lex nde random ## elite-10 1.0000 - - - - - ## tourn 0.0513 0.0079 - - - - ## lex &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 - - - ## nde 1.5e-07 1.1e-05 2.1e-13 &lt; 2e-16 - - ## random 8.3e-12 5.9e-11 6.1e-07 &lt; 2e-16 &lt; 2e-16 - ## none 0.0261 0.0017 1.0000 &lt; 2e-16 6.7e-16 5.4e-10 ## ## P value adjustment method: bonferroni # All sig p&lt;0.5, except tourn vs none 7.5.1 Metapopulation task coverage time series To speed up plotting, we graph a low-resolution version of this time series. metapop_task_cov_ot_fig &lt;- ggplot( # times_series_data, filter(times_series_data, (epoch_offset%%100)==0 | epoch_offset==1), aes( x=epoch_offset, y=total_trait_coverage, fill=SELECTION_METHOD, color=SELECTION_METHOD ) ) + stat_summary(geom=&quot;line&quot;, fun=mean) + stat_summary( geom=&quot;ribbon&quot;, fun.data=&quot;mean_cl_boot&quot;, fun.args=list(conf.int=0.95), alpha=0.2, linetype=0 ) + scale_x_continuous( name=&quot;Cycles&quot; ) + scale_y_continuous( name=&quot;Task Coverage&quot;, limits=c(-0.5,18.5), breaks=seq(0,18,2) ) + scale_fill_fun( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + scale_color_fun( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + theme( legend.position=&quot;bottom&quot; ) metapop_task_cov_ot_fig ## Warning: Computation failed in `stat_summary()`: ggsave( plot=metapop_task_cov_ot_fig, filename=paste0(plot_directory, &quot;2021-11-11-metapop-task-cov-ts.pdf&quot;), width=10, height=6 ) ## Warning: Computation failed in `stat_summary()`: 7.5.1.1 First 30 cycles of the experiment metapop_task_cov_ot_early_fig &lt;- ggplot( # times_series_data, filter(times_series_data, (epoch_offset &lt;= 30)), aes( x=epoch_offset, y=total_trait_coverage, fill=SELECTION_METHOD, color=SELECTION_METHOD ) ) + stat_summary(geom=&quot;line&quot;, fun=mean) + stat_summary( geom=&quot;ribbon&quot;, fun.data=&quot;mean_cl_boot&quot;, fun.args=list(conf.int=0.95), alpha=0.2, linetype=0 ) + scale_x_continuous( name=&quot;Cycles&quot; ) + scale_y_continuous( name=&quot;Task Coverage&quot;, limits=c(-0.5,18.5), breaks=seq(0,18,2) ) + scale_fill_fun( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + scale_color_fun( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + theme( legend.position=&quot;bottom&quot; ) metapop_task_cov_ot_early_fig ## Warning: Computation failed in `stat_summary()`: ggsave( filename=paste0(plot_directory, &quot;2021-11-11-metapop-task-cov-ts-early.pdf&quot;), width=10, height=6 ) ## Warning: Computation failed in `stat_summary()`: After just 10 cycles, we observed significant gains from using NDE and LEX selection protocols. early_data &lt;- filter(times_series_data, epoch_offset==10) kruskal.test( formula=total_trait_coverage~SELECTION_METHOD, data=early_data ) ## ## Kruskal-Wallis rank sum test ## ## data: total_trait_coverage by SELECTION_METHOD ## Kruskal-Wallis chi-squared = 180.78, df = 6, p-value &lt; 2.2e-16 # Kruskal-wallis is significant, so we do a post-hoc wilcoxon rank-sum. pairwise.wilcox.test( x=early_data$total_trait_coverage, g=early_data$SELECTION_METHOD, p.adjust.method=&quot;bonferroni&quot;, ) ## ## Pairwise comparisons using Wilcoxon rank sum test with continuity correction ## ## data: early_data$total_trait_coverage and early_data$SELECTION_METHOD ## ## elite elite-10 tourn lex nde random ## elite-10 0.06728 - - - - - ## tourn 0.01593 1.00000 - - - - ## lex 3.7e-14 9.8e-11 1.3e-11 - - - ## nde 1.7e-12 1.9e-07 1.8e-08 0.03737 - - ## random 1.00000 0.00627 0.00051 7.7e-16 4.9e-15 - ## none 1.00000 0.93717 0.28402 8.7e-15 2.6e-13 0.38944 ## ## P value adjustment method: bonferroni 7.6 Metapopulation task profile diversity We measured the phenotypic diversity within evolved metapopulations in three ways: the number of task profiles (richness) the spread of task profiles as the average cosine distance from the centroid profile the Shannon entropy of task profiles 7.6.1 Number of different task profiles num_pop_task_profiles_fig &lt;- ggplot( exp_summary_data, aes( x=SELECTION_METHOD, y=num_pop_trait_profiles, fill=SELECTION_METHOD ) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8 ) + geom_point( mapping=aes(color=SELECTION_METHOD), position = position_jitter(height=0, width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_y_continuous( name=&quot;# Different Task Profiles&quot; ) + scale_x_discrete( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + scale_fill_fun( ) + scale_color_fun( ) + theme( legend.position=&quot;none&quot; ) num_pop_task_profiles_fig ggsave( plot=num_pop_task_profiles_fig, paste0(plot_directory, &quot;2021-11-11-num-task-profiles.pdf&quot;) ) ## Saving 7 x 5 in image Statistical results: kruskal.test( formula=num_pop_trait_profiles~SELECTION_METHOD, data=exp_summary_data ) ## ## Kruskal-Wallis rank sum test ## ## data: num_pop_trait_profiles by SELECTION_METHOD ## Kruskal-Wallis chi-squared = 239.62, df = 6, p-value &lt; 2.2e-16 # Kruskal-wallis is significant, so we do a post-hoc wilcoxon rank-sum. pairwise.wilcox.test( x=exp_summary_data$num_pop_trait_profiles, g=exp_summary_data$SELECTION_METHOD, p.adjust.method=&quot;bonferroni&quot;, ) ## ## Pairwise comparisons using Wilcoxon rank sum test with continuity correction ## ## data: exp_summary_data$num_pop_trait_profiles and exp_summary_data$SELECTION_METHOD ## ## elite elite-10 tourn lex nde random ## elite-10 1 - - - - - ## tourn 1 1 - - - - ## lex &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 - - - ## nde 5.3e-16 &lt; 2e-16 &lt; 2e-16 3.2e-06 - - ## random 1 1 1 &lt; 2e-16 &lt; 2e-16 - ## none 6.2e-06 2.2e-06 5.1e-06 &lt; 2e-16 &lt; 2e-16 1.5e-07 ## ## P value adjustment method: bonferroni 7.6.1.1 Number of different task profiles over time num_task_profiles_ot_fig &lt;- ggplot( filter(times_series_data, (updates_elapsed%%10000)==0 | updates_elapsed==1), aes( x=updates_elapsed, y=num_pop_trait_profiles, fill=SELECTION_METHOD, color=SELECTION_METHOD ) ) + stat_summary(geom=&quot;line&quot;, fun=mean) + stat_summary( geom=&quot;ribbon&quot;, fun.data=&quot;mean_cl_boot&quot;, fun.args=list(conf.int=0.95), alpha=0.2, linetype=0 ) + scale_x_continuous( name=&quot;Updates elapsed&quot; ) + scale_y_continuous( name=&quot;# Different Task Profiles&quot; ) + scale_fill_fun( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + scale_color_fun( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + theme( legend.position=&quot;bottom&quot; ) num_task_profiles_ot_fig ## Warning: Computation failed in `stat_summary()`: ggsave( num_task_profiles_ot_fig, filename=paste0(plot_directory, &quot;2021-11-11-num-task-profiles-ts.png&quot;), width=10, height=6 ) ## Warning: Computation failed in `stat_summary()`: 7.6.2 Task profile spread task_profile_spread_fig &lt;- ggplot( exp_summary_data, aes( x=SELECTION_METHOD, y=avg_cosine_dist_from_centroid, fill=SELECTION_METHOD ) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8 ) + geom_point( mapping=aes(color=SELECTION_METHOD), position = position_jitter(height=0, width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_y_continuous( name=&quot;Avg. Task Spread&quot; ) + scale_x_discrete( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + scale_fill_fun( ) + scale_color_fun( ) + theme( legend.position=&quot;none&quot; ) task_profile_spread_fig ggsave( plot=task_profile_spread_fig, paste0(plot_directory, &quot;2021-11-11-task-profile-spread.pdf&quot;) ) ## Saving 7 x 5 in image Statistical results: kruskal.test( formula=avg_cosine_dist_from_centroid~SELECTION_METHOD, data=exp_summary_data ) ## ## Kruskal-Wallis rank sum test ## ## data: avg_cosine_dist_from_centroid by SELECTION_METHOD ## Kruskal-Wallis chi-squared = 292.39, df = 6, p-value &lt; 2.2e-16 # Kruskal-wallis is significant, so we do a post-hoc wilcoxon rank-sum. pairwise.wilcox.test( x=exp_summary_data$avg_cosine_dist_from_centroid, g=exp_summary_data$SELECTION_METHOD, p.adjust.method=&quot;bonferroni&quot;, ) ## ## Pairwise comparisons using Wilcoxon rank sum test with continuity correction ## ## data: exp_summary_data$avg_cosine_dist_from_centroid and exp_summary_data$SELECTION_METHOD ## ## elite elite-10 tourn lex nde random ## elite-10 1.00000 - - - - - ## tourn 0.00069 0.13725 - - - - ## lex &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 - - - ## nde &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 2.5e-16 - - ## random 1.8e-06 7.7e-08 1.0e-10 &lt; 2e-16 8.5e-13 - ## none &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 1.00000 2.6e-14 ## ## P value adjustment method: bonferroni 7.6.3 Task profile entropy ggplot( exp_summary_data, aes( x=SELECTION_METHOD, y=pop_trait_profile_entropy, fill=SELECTION_METHOD ) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8 ) + geom_point( mapping=aes(color=SELECTION_METHOD), position = position_jitter(height=0, width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_y_continuous( name=&quot;Shannon entropy of task profiles&quot; ) + scale_x_discrete( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + scale_fill_fun( ) + scale_color_fun( ) + theme( legend.position=&quot;none&quot; ) ggsave( paste0(plot_directory, &quot;2021-11-11-task-profile-entropy.pdf&quot;) ) ## Saving 7 x 5 in image Statistical results: kruskal.test( formula=pop_trait_profile_entropy~SELECTION_METHOD, data=exp_summary_data ) ## ## Kruskal-Wallis rank sum test ## ## data: pop_trait_profile_entropy by SELECTION_METHOD ## Kruskal-Wallis chi-squared = 237.28, df = 6, p-value &lt; 2.2e-16 pairwise.wilcox.test( x=exp_summary_data$pop_trait_profile_entropy, g=exp_summary_data$SELECTION_METHOD, p.adjust.method=&quot;bonferroni&quot;, ) ## ## Pairwise comparisons using Wilcoxon rank sum test with continuity correction ## ## data: exp_summary_data$pop_trait_profile_entropy and exp_summary_data$SELECTION_METHOD ## ## elite elite-10 tourn lex nde random ## elite-10 1 - - - - - ## tourn 1 1 - - - - ## lex &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 - - - ## nde 4.9e-16 4.1e-16 3.8e-16 1.3e-07 - - ## random 1 1 1 &lt; 2e-16 &lt; 2e-16 - ## none 3.9e-05 2.2e-05 4.7e-08 &lt; 2e-16 &lt; 2e-16 9.1e-06 ## ## P value adjustment method: bonferroni 7.6.3.1 Task entropy over time ggplot( filter(times_series_data, (updates_elapsed%%10000)==0 | updates_elapsed==1), aes( x=updates_elapsed, y=pop_trait_profile_entropy, fill=SELECTION_METHOD, color=SELECTION_METHOD ) ) + stat_summary(geom=&quot;line&quot;, fun=mean) + stat_summary( geom=&quot;ribbon&quot;, fun.data=&quot;mean_cl_boot&quot;, fun.args=list(conf.int=0.95), alpha=0.2, linetype=0 ) + scale_x_continuous( name=&quot;Updates elapsed&quot; ) + scale_y_continuous( name=&quot;Task profile entropy&quot; ) + scale_fill_fun( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + scale_color_fun( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + theme( legend.position=&quot;bottom&quot; ) ## Warning: Computation failed in `stat_summary()`: ggsave( filename=paste0(plot_directory, &quot;2021-11-11-pop-trait-profile-entropy-ts.png&quot;), width=10, height=6 ) ## Warning: Computation failed in `stat_summary()`: 7.7 Task coverage per N populations We analyzed the (maximum) number of tasks added to metapopulation task coverage for a given number (N) of member populations considered. That is, for each N, we solved the maximum set coverage problem for task coverage: what is the maximum number of tasks that can be covered given N populations from this metapopulation? ggplot( task_coverage_per_pop_data, aes( x=n_pops, y=max_tasks_covered, fill=SELECTION_METHOD, color=SELECTION_METHOD ) ) + stat_summary(geom=&quot;line&quot;, fun=mean) + stat_summary( geom=&quot;ribbon&quot;, fun.data=&quot;mean_cl_boot&quot;, fun.args=list(conf.int=0.95), alpha=0.2, linetype=0 ) + scale_y_continuous( name=&quot;Maximum task coverage&quot; ) + scale_x_continuous( name=&quot;Number of populations&quot;, limits=c(0, 15) ) + scale_fill_fun( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + scale_color_fun( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + theme( legend.position=&quot;bottom&quot; ) ## Warning: Removed 28350 rows containing non-finite values (stat_summary). ## Removed 28350 rows containing non-finite values (stat_summary). ## Warning: Computation failed in `stat_summary()`: ggsave( paste0(plot_directory, &quot;2021-11-11-task-cov-per-n-pops.pdf&quot;), width=10, height=6 ) ## Warning: Removed 28350 rows containing non-finite values (stat_summary). ## Warning: Removed 28350 rows containing non-finite values (stat_summary). ## Warning: Computation failed in `stat_summary()`: ggplot( filter( task_coverage_per_pop_data, n_pops &gt; 0 &amp; n_pops &lt;= 5 ), aes( x=SELECTION_METHOD, y=max_tasks_covered, fill=SELECTION_METHOD ) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8 ) + geom_point( mapping=aes(color=SELECTION_METHOD), position = position_jitter(height=0, width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_y_continuous( name=&quot;Maximum task coverage&quot; ) + scale_x_discrete( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + scale_fill_fun( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + scale_color_fun( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + facet_wrap( ~n_pops, nrow=1, labeller=label_both ) + theme( legend.position=&quot;bottom&quot;, axis.text.x = element_blank() ) ggsave( paste0(plot_directory, &quot;2021-11-11-task-cov-per-n-pops-alt.pdf&quot;), width=10, height=6 ) 7.8 Average number of different populations selected per generation ggplot( exp_summary_data, aes( x=SELECTION_METHOD, y=avg_unique_selected, fill=SELECTION_METHOD ) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8 ) + geom_point( mapping=aes(color=SELECTION_METHOD), position = position_jitter(height=0, width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_y_continuous( name=&quot;Avg. number selected&quot; ) + scale_x_discrete( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + scale_fill_fun( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + scale_color_fun( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + theme( legend.position=&quot;none&quot; ) ggsave( paste0(plot_directory, &quot;2021-11-11-num-selected.pdf&quot;) ) ## Saving 7 x 5 in image mean(filter(exp_summary_data, SELECTION_METHOD==&quot;elite&quot;)$avg_unique_selected) ## [1] 1 mean(filter(exp_summary_data, SELECTION_METHOD==&quot;elite-10&quot;)$avg_unique_selected) ## [1] 10 mean(filter(exp_summary_data, SELECTION_METHOD==&quot;tourn&quot;)$avg_unique_selected) ## [1] 50.14939 mean(filter(exp_summary_data, SELECTION_METHOD==&quot;nde&quot;)$avg_unique_selected) ## [1] 83.29294 mean(filter(exp_summary_data, SELECTION_METHOD==&quot;lex&quot;)$avg_unique_selected) ## [1] 12.36869 mean(filter(exp_summary_data, SELECTION_METHOD==&quot;random&quot;)$avg_unique_selected) ## [1] 60.87775 7.8.1 Entropy of selected population IDs ggplot( exp_summary_data, aes( x=SELECTION_METHOD, y=avg_entropy_selected, fill=SELECTION_METHOD ) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8 ) + geom_point( mapping=aes(color=SELECTION_METHOD), position = position_jitter(height=0, width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_fill_fun( ) + scale_color_fun( ) + theme( legend.position=&quot;none&quot; ) 7.9 Average number of organisms in populations at end of maturation period ggplot( exp_summary_data, aes( x=SELECTION_METHOD, y=avg_num_orgs, fill=SELECTION_METHOD ) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8 ) + geom_point( mapping=aes(color=SELECTION_METHOD), position = position_jitter(width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_y_continuous( name=&quot;Average number of organisms&quot;, limits=c(950, 1000) ) + scale_x_discrete( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + scale_fill_fun( ) + scale_color_fun( ) + theme( legend.position=&quot;none&quot; ) ggsave( paste0(plot_directory, &quot;2021-11-11-num-orgs.pdf&quot;) ) ## Saving 7 x 5 in image 7.10 Average generations per maturation period ggplot( exp_summary_data, aes( x=SELECTION_METHOD, y=avg_gens, fill=SELECTION_METHOD ) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8 ) + geom_point( mapping=aes(color=SELECTION_METHOD), position = position_jitter(width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_y_continuous( name=&quot;Average generations per maturation period&quot; ) + scale_x_discrete( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + scale_fill_fun( ) + scale_color_fun( ) + theme( legend.position=&quot;none&quot; ) ggsave( paste0(plot_directory, &quot;2021-11-11-avg-gens.pdf&quot;) ) ## Saving 7 x 5 in image median(exp_summary_data$total_gens_approx) # Used for determining how many generations to run EC for ## [1] 57365.67 7.11 Representative task profiles Visualized task profiles of two example metapopulations. Elite selection knitr::include_graphics(&quot;https://raw.githubusercontent.com/amlalejini/directed-digital-evolution/main/docs/media/metapop-profiles/profile_70007_elite.png&quot;) Lexicase selection knitr::include_graphics(&quot;https://raw.githubusercontent.com/amlalejini/directed-digital-evolution/main/docs/media/metapop-profiles/profile_70110_lex.png&quot;) 7.12 Manuscript figures Without time series: grid &lt;- plot_grid( max_trait_cov_fig + theme( axis.title.x=element_blank(), axis.text=element_text(size=10), plot.title=element_text(size=12), axis.text.x = element_text(size = 9), axis.title.y = element_text(size = 10) ) + ggtitle(&quot;Best population task coverage&quot;), total_trait_cov_fig + theme( axis.title.x=element_blank(), plot.title=element_text(size=12), axis.text=element_text(size=10), axis.text.x = element_text(size = 9), axis.title.y = element_text(size = 10) ) + ggtitle(&quot;Metapopulation task coverage&quot;), num_pop_task_profiles_fig + theme( axis.text=element_text(size=10), plot.title=element_text(size=12), axis.text.x = element_text(size = 9), axis.title.y = element_text(size = 10) ) + ggtitle(&quot;Diversity of task profiles&quot;), task_profile_spread_fig + theme( axis.text=element_text(size=10), plot.title=element_text(size=12), axis.text.x = element_text(size = 9), axis.title.y = element_text(size = 10) ) + ggtitle(&quot;Spread of task profiles&quot;), nrow=2, ncol=2, labels=&quot;auto&quot; ) grid save_plot( filename=paste0(plot_directory, &quot;2021-11-11-selection-figure.pdf&quot;), plot=grid, base_height=5, base_asp=2.5, dpi=600 ) With time series: legend &lt;- cowplot::get_legend( max_trait_cov_ot_fig + guides( color=guide_legend(nrow=1), fill=guide_legend(nrow=1) ) + theme( legend.position = &quot;bottom&quot;, legend.box=&quot;horizontal&quot;, legend.justification=&quot;center&quot; ) ) ## Warning: Computation failed in `stat_summary()`: max_trait_cov_row &lt;- plot_grid( max_trait_cov_ot_fig + ggtitle(&quot;Best population task coverage (over time)&quot;) + theme( legend.position=&quot;none&quot; # plot.title=element_text(size=12), # axis.text=element_text(size=10), # axis.text.x = element_text(size = 9), # axis.title.y = element_text(size = 10) ), max_trait_cov_fig + ggtitle(&quot;Best population task coverage (final)&quot;), theme( legend.position=&quot;none&quot; # plot.title=element_text(size=12), # axis.text=element_text(size=10), # axis.text.x = element_text(size = 9), # axis.title.y = element_text(size = 10) ), nrow=1, ncol=2, align=&quot;h&quot;, labels=c(&quot;a&quot;, &quot;b&quot;) # rel_widths=c(3,2), ) ## Warning: Computation failed in `stat_summary()`: ## Warning in as_grob.default(plot): Cannot convert object of class themegg into a ## grob. ## Warning: Graphs cannot be horizontally aligned unless the axis parameter is set. ## Placing graphs unaligned. # max_trait_cov_row total_trait_cov_row &lt;- plot_grid( metapop_task_cov_ot_fig + ggtitle(&quot;Metapopulation task coverage (over time)&quot;) + theme( legend.position=&quot;none&quot; # plot.title=element_text(size=12), # axis.text=element_text(size=10), # axis.text.x = element_text(size = 9), # axis.title.y = element_text(size = 10) ), total_trait_cov_fig + ggtitle(&quot;Metapopulation task coverage (final)&quot;), theme( legend.position=&quot;none&quot; # plot.title=element_text(size=12), # axis.text=element_text(size=10), # axis.text.x = element_text(size = 9), # axis.title.y = element_text(size = 10) ), nrow=1, ncol=2, align=&quot;h&quot;, labels=c(&quot;c&quot;, &quot;d&quot;) # rel_widths=c(3,2), ) ## Warning: Computation failed in `stat_summary()`: ## Warning in as_grob.default(plot): Cannot convert object of class themegg into a ## grob. ## Warning: Graphs cannot be horizontally aligned unless the axis parameter is set. ## Placing graphs unaligned. # total_trait_cov_row diversity_row &lt;- plot_grid( num_pop_task_profiles_fig + ggtitle(&quot;Diversity of task profiles&quot;) + theme( legend.position=&quot;none&quot; # plot.title=element_text(size=12), # axis.text=element_text(size=10), # axis.text.x = element_text(size = 9), # axis.title.y = element_text(size = 10) ), task_profile_spread_fig + ggtitle(&quot;Spread of task profiles&quot;), theme( legend.position=&quot;none&quot; # plot.title=element_text(size=12), # axis.text=element_text(size=10), # axis.text.x = element_text(size = 9), # axis.title.y = element_text(size = 10) ), nrow=1, ncol=2, align=&quot;h&quot;, labels=c(&quot;e&quot;, &quot;f&quot;) # rel_widths=c(3,2), ) ## Warning in as_grob.default(plot): Cannot convert object of class themegg into a ## grob. ## Warning in as_grob.default(plot): Graphs cannot be horizontally aligned unless ## the axis parameter is set. Placing graphs unaligned. # diversity_row grid &lt;- plot_grid( max_trait_cov_row, total_trait_cov_row, diversity_row, legend, nrow=4, ncol=1, rel_heights=c(1, 1, 1, 0.1) ) grid save_plot( filename=paste0(plot_directory, &quot;2021-11-11-selection-figure-with-timeseries.pdf&quot;), plot=grid, base_width=12, base_height=10, # base_asp=1.6, dpi=600 ) "],["aligned-individual-level-and-population-level-task-directed-evolution-experiment.html", "Chapter 8 Aligned individual-level and population-level task directed evolution experiment 8.1 Overview 8.2 Analysis dependencies 8.3 Setup 8.4 Best single-population task coverage 8.5 Metapopulation task coverage 8.6 Metapopulation task profile diversity 8.7 Task coverage per N populations 8.8 Average number of different populations selected per generation 8.9 Average number of organisms in populations at end of maturation period 8.10 Average generations per maturation period 8.11 Manuscript figures", " Chapter 8 Aligned individual-level and population-level task directed evolution experiment 8.1 Overview Supplemental information and data analyses for the directed evolution experiment where rewards for individual- and population-level tasks are aligned. experiment_slug &lt;- &quot;2021-11-30-aligned-tasks&quot; working_directory &lt;- paste0(&quot;experiments/&quot;,experiment_slug,&quot;/analysis/&quot;) 8.2 Analysis dependencies Load all required R libraries library(tidyverse) library(ggplot2) library(cowplot) library(RColorBrewer) library(khroma) source(&quot;https://gist.githubusercontent.com/benmarwick/2a1bb0133ff568cbe28d/raw/fb53bd97121f7f9ce947837ef1a4c65a73bffb3f/geom_flat_violin.R&quot;) These analyses were knit with the following environment: print(version) ## _ ## platform x86_64-pc-linux-gnu ## arch x86_64 ## os linux-gnu ## system x86_64, linux-gnu ## status ## major 4 ## minor 2.1 ## year 2022 ## month 06 ## day 23 ## svn rev 82513 ## language R ## version.string R version 4.2.1 (2022-06-23) ## nickname Funny-Looking Kid 8.3 Setup Load experiment summary data. exp_summary_data_loc &lt;- paste0(working_directory,&quot;data/experiment_summary.csv&quot;) exp_summary_data &lt;- read.csv(exp_summary_data_loc, na.strings=&quot;NONE&quot;) exp_summary_data$SELECTION_METHOD &lt;- factor( exp_summary_data$SELECTION_METHOD, levels=c( &quot;elite&quot;, &quot;elite-10&quot;, &quot;tournament&quot;, &quot;lexicase&quot;, &quot;non-dominated-elite&quot;, &quot;random&quot;, &quot;none&quot; ), labels=c( &quot;elite&quot;, &quot;elite-10&quot;, &quot;tourn&quot;, &quot;lex&quot;, &quot;nde&quot;, &quot;random&quot;, &quot;none&quot; ) ) Load time series data. times_series_data_loc &lt;- paste0(working_directory,&quot;data/evaluation_time_series_corrected.csv&quot;) times_series_data &lt;- read.csv(times_series_data_loc, na.strings=&quot;NONE&quot;) # Specify experimental condition for each datum. times_series_data$SELECTION_METHOD &lt;- factor( times_series_data$SELECTION_METHOD, levels=c( &quot;elite&quot;, &quot;elite-10&quot;, &quot;tournament&quot;, &quot;lexicase&quot;, &quot;non-dominated-elite&quot;, &quot;non-dominated-tournament&quot;, &quot;random&quot;, &quot;none&quot; ), labels=c( &quot;elite&quot;, &quot;elite-10&quot;, &quot;tourn&quot;, &quot;lex&quot;, &quot;nde&quot;, &quot;ndt&quot;, &quot;random&quot;, &quot;none&quot; ) ) times_series_data$epoch_offset &lt;- times_series_data$epoch+1 Load task coverage per population data. task_coverage_per_pop_data_loc &lt;- paste0(working_directory,&quot;data/max_coverage_per_pop_cnt.csv&quot;) task_coverage_per_pop_data &lt;- read.csv(task_coverage_per_pop_data_loc, na.strings=&quot;NONE&quot;) # Specify experimental condition for each datum. task_coverage_per_pop_data$SELECTION_METHOD &lt;- factor( task_coverage_per_pop_data$SELECTION_METHOD, levels=c( &quot;elite&quot;, &quot;elite-10&quot;, &quot;tournament&quot;, &quot;lexicase&quot;, &quot;non-dominated-elite&quot;, &quot;non-dominated-tournament&quot;, &quot;random&quot;, &quot;none&quot; ), labels=c( &quot;elite&quot;, &quot;elite-10&quot;, &quot;tourn&quot;, &quot;lex&quot;, &quot;nde&quot;, &quot;ndt&quot;, &quot;random&quot;, &quot;none&quot; ) ) Miscellaneous setup # Configure our default graphing theme theme_set(theme_cowplot()) # Palette scale_fill_fun &lt;- scale_fill_bright scale_color_fun &lt;- scale_color_bright alpha &lt;- 0.05 # Create a directory to store plots plot_directory &lt;- paste0(working_directory, &quot;plots/&quot;) dir.create(plot_directory, showWarnings=FALSE) p_label &lt;- function(p_value) { threshold = 0.0001 if (p_value &lt; threshold) { return(paste0(&quot;p &lt; &quot;, threshold)) } else { return(paste0(&quot;p = &quot;, p_value)) } } selection_method_breaks &lt;- c(&quot;elite&quot;, &quot;elite-10&quot;, &quot;tourn&quot;, &quot;lex&quot;, &quot;nde&quot;, &quot;random&quot;, &quot;none&quot;) selection_method_labels &lt;- c(&quot;ELITE&quot;, &quot;TOP-10&quot;, &quot;TOURN&quot;, &quot;LEX&quot;, &quot;NDE&quot;, &quot;RAND&quot;, &quot;NONE&quot;) 8.4 Best single-population task coverage max_trait_cov_fig &lt;- ggplot( exp_summary_data, aes( x=SELECTION_METHOD, y=max_trait_coverage, fill=SELECTION_METHOD ) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8, adjust=1.5 ) + geom_point( mapping=aes(color=SELECTION_METHOD), position = position_jitter(height=0.1, width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_y_continuous( name=&quot;Task Coverage&quot;, limits=c(-0.5,18), breaks=seq(0,18,2) ) + scale_x_discrete( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + scale_fill_fun( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels, ) + scale_color_fun( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels, ) + theme( legend.position=&quot;none&quot; ) max_trait_cov_fig ggsave( plot=max_trait_cov_fig, paste0(plot_directory, &quot;2021-11-30-best-pop-task-cov.pdf&quot;) ) ## Saving 7 x 5 in image Statistical results: kruskal.test( formula=max_trait_coverage~SELECTION_METHOD, data=exp_summary_data ) ## ## Kruskal-Wallis rank sum test ## ## data: max_trait_coverage by SELECTION_METHOD ## Kruskal-Wallis chi-squared = 232.92, df = 6, p-value &lt; 2.2e-16 # Kruskal-wallis is significant, so we do a post-hoc wilcoxon rank-sum. pairwise.wilcox.test( x=exp_summary_data$max_trait_coverage, g=exp_summary_data$SELECTION_METHOD, p.adjust.method=&quot;bonferroni&quot;, ) ## ## Pairwise comparisons using Wilcoxon rank sum test with continuity correction ## ## data: exp_summary_data$max_trait_coverage and exp_summary_data$SELECTION_METHOD ## ## elite elite-10 tourn lex nde random ## elite-10 0.713 - - - - - ## tourn 1.000 1.000 - - - - ## lex 5.7e-07 5.4e-10 1.5e-11 - - - ## nde 1.000 0.056 0.098 2.0e-09 - - ## random 2.2e-15 3.6e-16 &lt; 2e-16 2.4e-16 &lt; 2e-16 - ## none 4.9e-12 7.1e-14 1.9e-15 7.8e-08 7.5e-15 3.6e-11 ## ## P value adjustment method: bonferroni 8.4.1 Best single-population task coverage time series To speed up graphing, we plot a low-resolution version of the time series. max_trait_cov_ot_fig &lt;- ggplot( # times_series_data, filter(times_series_data, (epoch_offset%%10)==0 | epoch_offset==1), aes( x=epoch_offset, y=max_trait_coverage, fill=SELECTION_METHOD, color=SELECTION_METHOD ) ) + stat_summary(geom=&quot;line&quot;, fun=mean) + stat_summary( geom=&quot;ribbon&quot;, fun.data=&quot;mean_cl_boot&quot;, fun.args=list(conf.int=0.95), alpha=0.2, linetype=0 ) + scale_x_continuous( name=&quot;Cycle&quot; ) + scale_y_continuous( name=&quot;Task Coverage&quot;, limits=c(-0.5,18), breaks=seq(0,18,2) ) + scale_fill_fun( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + scale_color_fun( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + theme( legend.position=&quot;bottom&quot; ) max_trait_cov_ot_fig ## Warning: Computation failed in `stat_summary()`: ggsave( plot=max_trait_cov_ot_fig, filename=paste0(plot_directory, &quot;2021-11-30-best-pop-task-cov-ts.pdf&quot;), width=10, height=6 ) ## Warning: Computation failed in `stat_summary()`: 8.4.1.1 First 30 cycles of the experiment max_trait_cov_ot_early_fig &lt;- ggplot( # times_series_data, filter(times_series_data, (epoch_offset &lt;= 30)), aes( x=epoch_offset, y=max_trait_coverage, fill=SELECTION_METHOD, color=SELECTION_METHOD ) ) + stat_summary(geom=&quot;line&quot;, fun=mean) + stat_summary( geom=&quot;ribbon&quot;, fun.data=&quot;mean_cl_boot&quot;, fun.args=list(conf.int=0.95), alpha=0.2, linetype=0 ) + scale_x_continuous( name=&quot;Cycles&quot; ) + scale_y_continuous( name=&quot;Task Coverage&quot;, limits=c(-0.5,18.5), breaks=seq(0,18,2) ) + scale_fill_fun( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + scale_color_fun( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + theme( legend.position=&quot;bottom&quot; ) max_trait_cov_ot_early_fig ## Warning: Computation failed in `stat_summary()`: ggsave( filename=paste0(plot_directory, &quot;2021-11-30-best-pop-task-cov-ts-early.pdf&quot;), width=10, height=6 ) ## Warning: Computation failed in `stat_summary()`: 8.5 Metapopulation task coverage total_trait_cov_fig &lt;- ggplot( exp_summary_data, aes( x=SELECTION_METHOD, y=total_trait_coverage, fill=SELECTION_METHOD ) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8, adjust=1.5 ) + geom_point( mapping=aes(color=SELECTION_METHOD), position = position_jitter(height=0.1, width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_y_continuous( name=&quot;Task Coverage&quot;, limits=c(-0.5,18.5), breaks=seq(0,18,2) ) + scale_x_discrete( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + scale_fill_fun( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + scale_color_fun( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + theme( legend.position=&quot;none&quot; ) total_trait_cov_fig ggsave( plot=total_trait_cov_fig, paste0(plot_directory, &quot;2021-11-30-metapop-task-cov.pdf&quot;) ) ## Saving 7 x 5 in image Statistical results: kruskal.test( formula=total_trait_coverage~SELECTION_METHOD, data=exp_summary_data ) ## ## Kruskal-Wallis rank sum test ## ## data: total_trait_coverage by SELECTION_METHOD ## Kruskal-Wallis chi-squared = 269.5, df = 6, p-value &lt; 2.2e-16 # Kruskal-wallis is significant, so we do a post-hoc wilcoxon rank-sum. pairwise.wilcox.test( x=exp_summary_data$total_trait_coverage, g=exp_summary_data$SELECTION_METHOD, p.adjust.method=&quot;bonferroni&quot;, ) ## ## Pairwise comparisons using Wilcoxon rank sum test with continuity correction ## ## data: exp_summary_data$total_trait_coverage and exp_summary_data$SELECTION_METHOD ## ## elite elite-10 tourn lex nde random ## elite-10 1.00000 - - - - - ## tourn 1.00000 1.00000 - - - - ## lex &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 - - - ## nde 2.2e-14 2.6e-12 6.9e-15 1.1e-15 - - ## random 7.7e-11 5.6e-13 6.2e-14 &lt; 2e-16 &lt; 2e-16 - ## none 2.2e-08 0.00014 3.1e-06 &lt; 2e-16 4.9e-08 &lt; 2e-16 ## ## P value adjustment method: bonferroni 8.5.1 Metapopulation task coverage time series To speed up graphing, we plot a low-resolution version of the time series. metapop_task_cov_ot_fig &lt;- ggplot( # times_series_data, filter(times_series_data, (epoch_offset%%10)==0 | epoch_offset==1), aes( x=epoch_offset, y=total_trait_coverage, fill=SELECTION_METHOD, color=SELECTION_METHOD ) ) + stat_summary(geom=&quot;line&quot;, fun=mean) + stat_summary( geom=&quot;ribbon&quot;, fun.data=&quot;mean_cl_boot&quot;, fun.args=list(conf.int=0.95), alpha=0.2, linetype=0 ) + scale_x_continuous( name=&quot;Cycle&quot; ) + scale_y_continuous( name=&quot;Task Coverage&quot;, limits=c(-0.5,18.5), breaks=seq(0,18,2) ) + scale_fill_fun( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + scale_color_fun( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + theme( legend.position=&quot;bottom&quot; ) metapop_task_cov_ot_fig ## Warning: Computation failed in `stat_summary()`: ggsave( plot=metapop_task_cov_ot_fig, filename=paste0(plot_directory, &quot;2021-11-30-metapop-task-cov-ts.pdf&quot;), width=10, height=6 ) ## Warning: Computation failed in `stat_summary()`: 8.5.1.1 First 30 cycles of the experiment metapop_task_cov_ot_early_fig &lt;- ggplot( # times_series_data, filter(times_series_data, (epoch_offset &lt;= 30)), aes( x=epoch_offset, y=total_trait_coverage, fill=SELECTION_METHOD, color=SELECTION_METHOD ) ) + stat_summary(geom=&quot;line&quot;, fun=mean) + stat_summary( geom=&quot;ribbon&quot;, fun.data=&quot;mean_cl_boot&quot;, fun.args=list(conf.int=0.95), alpha=0.2, linetype=0 ) + scale_x_continuous( name=&quot;Cycles&quot; ) + scale_y_continuous( name=&quot;Task Coverage&quot;, limits=c(-0.5,18.5), breaks=seq(0,18,2) ) + scale_fill_fun( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + scale_color_fun( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + theme( legend.position=&quot;bottom&quot; ) metapop_task_cov_ot_early_fig ## Warning: Computation failed in `stat_summary()`: ggsave( filename=paste0(plot_directory, &quot;2021-11-30-metapop-task-cov-ts-early.pdf&quot;), width=10, height=6 ) ## Warning: Computation failed in `stat_summary()`: After just 10 cycles, we observed significant gains from using NDE and LEX selection protocols. early_data &lt;- filter(times_series_data, epoch_offset==10) kruskal.test( formula=total_trait_coverage~SELECTION_METHOD, data=early_data ) ## ## Kruskal-Wallis rank sum test ## ## data: total_trait_coverage by SELECTION_METHOD ## Kruskal-Wallis chi-squared = 202.89, df = 6, p-value &lt; 2.2e-16 # Kruskal-wallis is significant, so we do a post-hoc wilcoxon rank-sum. pairwise.wilcox.test( x=early_data$total_trait_coverage, g=early_data$SELECTION_METHOD, p.adjust.method=&quot;bonferroni&quot;, ) ## ## Pairwise comparisons using Wilcoxon rank sum test with continuity correction ## ## data: early_data$total_trait_coverage and early_data$SELECTION_METHOD ## ## elite elite-10 tourn lex nde random ## elite-10 1.0000 - - - - - ## tourn 0.1043 1.0000 - - - - ## lex 4.0e-16 5.5e-15 2.6e-12 - - - ## nde 3.6e-16 4.2e-15 2.5e-12 1.0000 - - ## random 5.3e-05 0.0062 1.0000 2.8e-14 4.7e-14 - ## none 9.9e-06 0.0013 1.0000 3.8e-13 3.1e-13 1.0000 ## ## P value adjustment method: bonferroni 8.6 Metapopulation task profile diversity We measured the phenotypic diversity within evolved metapopulations in three ways: the number of task profiles (richness) the spread of task profiles as the average cosine distance from the centroid profile the Shannon entropy of task profiles 8.6.1 Number of different task profiles num_pop_task_profiles_fig &lt;- ggplot( exp_summary_data, aes( x=SELECTION_METHOD, y=num_pop_trait_profiles, fill=SELECTION_METHOD ) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8 ) + geom_point( mapping=aes(color=SELECTION_METHOD), position = position_jitter(height=0, width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_y_continuous( name=&quot;# Different Task Profiles&quot; ) + scale_x_discrete( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + scale_fill_fun( ) + scale_color_fun( ) + theme( legend.position=&quot;none&quot; ) num_pop_task_profiles_fig ggsave( plot=num_pop_task_profiles_fig, paste0(plot_directory, &quot;2021-11-30-num-task-profiles.pdf&quot;) ) ## Saving 7 x 5 in image Statistical results kruskal.test( formula=num_pop_trait_profiles~SELECTION_METHOD, data=exp_summary_data ) ## ## Kruskal-Wallis rank sum test ## ## data: num_pop_trait_profiles by SELECTION_METHOD ## Kruskal-Wallis chi-squared = 247.78, df = 6, p-value &lt; 2.2e-16 # Kruskal-wallis is significant, so we do a post-hoc wilcoxon rank-sum. pairwise.wilcox.test( x=exp_summary_data$num_pop_trait_profiles, g=exp_summary_data$SELECTION_METHOD, p.adjust.method=&quot;bonferroni&quot;, ) ## ## Pairwise comparisons using Wilcoxon rank sum test with continuity correction ## ## data: exp_summary_data$num_pop_trait_profiles and exp_summary_data$SELECTION_METHOD ## ## elite elite-10 tourn lex nde random ## elite-10 1.00000 - - - - - ## tourn 0.12006 1.00000 - - - - ## lex 9.0e-07 0.00066 0.64177 - - - ## nde &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 - - ## random 1.00000 0.19565 0.00081 2.5e-10 &lt; 2e-16 - ## none &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 ## ## P value adjustment method: bonferroni 8.6.1.1 Number of different task profiles over time To speed up graphing, we reduced the time series resolution in this plot. num_task_profiles_ot_fig &lt;- ggplot( filter(times_series_data, (updates_elapsed%%10000)==0 | updates_elapsed==1), aes( x=updates_elapsed, y=num_pop_trait_profiles, fill=SELECTION_METHOD, color=SELECTION_METHOD ) ) + stat_summary(geom=&quot;line&quot;, fun=mean) + stat_summary( geom=&quot;ribbon&quot;, fun.data=&quot;mean_cl_boot&quot;, fun.args=list(conf.int=0.95), alpha=0.2, linetype=0 ) + scale_x_continuous( name=&quot;Updates elapsed&quot; ) + scale_y_continuous( name=&quot;# Different Task Profiles&quot; ) + scale_fill_fun( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + scale_color_fun( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + theme( legend.position=&quot;bottom&quot; ) num_task_profiles_ot_fig ## Warning: Computation failed in `stat_summary()`: ggsave( num_task_profiles_ot_fig, filename=paste0(plot_directory, &quot;2021-11-30-num-task-profiles-ts.png&quot;), width=10, height=6 ) ## Warning: Computation failed in `stat_summary()`: 8.6.2 Task profile spread task_profile_spread_fig &lt;- ggplot( exp_summary_data, aes( x=SELECTION_METHOD, y=avg_cosine_dist_from_centroid, fill=SELECTION_METHOD ) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8 ) + geom_point( mapping=aes(color=SELECTION_METHOD), position = position_jitter(height=0, width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_y_continuous( name=&quot;Avg. Task Spread&quot; ) + scale_x_discrete( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + scale_fill_fun( ) + scale_color_fun( ) + theme( legend.position=&quot;none&quot; ) task_profile_spread_fig ggsave( plot=task_profile_spread_fig, paste0(plot_directory, &quot;2021-11-30-task-profile-spread.pdf&quot;) ) ## Saving 7 x 5 in image Statistical results: kruskal.test( formula=avg_cosine_dist_from_centroid~SELECTION_METHOD, data=exp_summary_data ) ## ## Kruskal-Wallis rank sum test ## ## data: avg_cosine_dist_from_centroid by SELECTION_METHOD ## Kruskal-Wallis chi-squared = 281.91, df = 6, p-value &lt; 2.2e-16 # Kruskal-wallis is significant, so we do a post-hoc wilcoxon rank-sum. pairwise.wilcox.test( x=exp_summary_data$avg_cosine_dist_from_centroid, g=exp_summary_data$SELECTION_METHOD, p.adjust.method=&quot;bonferroni&quot;, ) ## ## Pairwise comparisons using Wilcoxon rank sum test with continuity correction ## ## data: exp_summary_data$avg_cosine_dist_from_centroid and exp_summary_data$SELECTION_METHOD ## ## elite elite-10 tourn lex nde random ## elite-10 1.0000 - - - - - ## tourn 0.0644 0.6009 - - - - ## lex &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 - - - ## nde &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 7.5e-15 - - ## random 0.0015 0.0121 0.4682 &lt; 2e-16 1.3e-15 - ## none &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 3.7e-09 5.4e-14 ## ## P value adjustment method: bonferroni 8.6.3 Task profile entropy ggplot( exp_summary_data, aes( x=SELECTION_METHOD, y=pop_trait_profile_entropy, fill=SELECTION_METHOD ) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8 ) + geom_point( mapping=aes(color=SELECTION_METHOD), position = position_jitter(height=0, width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_y_continuous( name=&quot;Shannon entropy of task profiles&quot; ) + scale_x_discrete( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + scale_fill_fun( ) + scale_color_fun( ) + theme( legend.position=&quot;none&quot; ) ggsave( paste0(plot_directory, &quot;2021-11-30-task-profile-entropy.pdf&quot;) ) ## Saving 7 x 5 in image Statistical results: kruskal.test( formula=pop_trait_profile_entropy~SELECTION_METHOD, data=exp_summary_data ) ## ## Kruskal-Wallis rank sum test ## ## data: pop_trait_profile_entropy by SELECTION_METHOD ## Kruskal-Wallis chi-squared = 271.97, df = 6, p-value &lt; 2.2e-16 pairwise.wilcox.test( x=exp_summary_data$pop_trait_profile_entropy, g=exp_summary_data$SELECTION_METHOD, p.adjust.method=&quot;bonferroni&quot;, ) ## ## Pairwise comparisons using Wilcoxon rank sum test with continuity correction ## ## data: exp_summary_data$pop_trait_profile_entropy and exp_summary_data$SELECTION_METHOD ## ## elite elite-10 tourn lex nde random ## elite-10 1.00 - - - - - ## tourn 0.12 1.00 - - - - ## lex 5.2e-16 5.1e-14 2.4e-10 - - - ## nde &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 - - ## random 0.77 1.00 1.00 6.2e-13 &lt; 2e-16 - ## none &lt; 2e-16 &lt; 2e-16 3.0e-16 2.3e-16 &lt; 2e-16 &lt; 2e-16 ## ## P value adjustment method: bonferroni 8.7 Task coverage per N populations We analyzed the (maximum) number of tasks added to metapopulation task coverage for a given number (N) of member populations considered. That is, for each N, we solved the maximum set coverage problem for task coverage: what is the maximum number of tasks that can be covered given N populations from this metapopulation? ggplot( task_coverage_per_pop_data, aes( x=n_pops, y=max_tasks_covered, fill=SELECTION_METHOD, color=SELECTION_METHOD ) ) + stat_summary(geom=&quot;line&quot;, fun=mean) + stat_summary( geom=&quot;ribbon&quot;, fun.data=&quot;mean_cl_boot&quot;, fun.args=list(conf.int=0.95), alpha=0.2, linetype=0 ) + scale_y_continuous( name=&quot;Maximum task coverage&quot; ) + scale_x_continuous( name=&quot;Number of populations&quot;, limits=c(0, 15) ) + scale_fill_fun( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + scale_color_fun( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + theme( legend.position=&quot;bottom&quot; ) ## Warning: Removed 28350 rows containing non-finite values (stat_summary). ## Removed 28350 rows containing non-finite values (stat_summary). ## Warning: Computation failed in `stat_summary()`: ggsave( paste0(plot_directory, &quot;2021-11-30-task-cov-per-n-pops.pdf&quot;), width=10, height=6 ) ## Warning: Removed 28350 rows containing non-finite values (stat_summary). ## Warning: Removed 28350 rows containing non-finite values (stat_summary). ## Warning: Computation failed in `stat_summary()`: 8.8 Average number of different populations selected per generation ggplot( exp_summary_data, aes( x=SELECTION_METHOD, y=avg_unique_selected, fill=SELECTION_METHOD ) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8 ) + geom_point( mapping=aes(color=SELECTION_METHOD), position = position_jitter(height=0, width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_y_continuous( name=&quot;Avg. number selected&quot; ) + scale_x_discrete( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + scale_fill_fun( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + scale_color_fun( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + theme( legend.position=&quot;none&quot; ) ggsave( paste0(plot_directory, &quot;2021-11-30-num-selected.pdf&quot;) ) ## Saving 7 x 5 in image mean(filter(exp_summary_data, SELECTION_METHOD==&quot;elite&quot;)$avg_unique_selected) ## [1] 1 mean(filter(exp_summary_data, SELECTION_METHOD==&quot;elite-10&quot;)$avg_unique_selected) ## [1] 10 mean(filter(exp_summary_data, SELECTION_METHOD==&quot;tourn&quot;)$avg_unique_selected) ## [1] 50.1328 mean(filter(exp_summary_data, SELECTION_METHOD==&quot;nde&quot;)$avg_unique_selected) ## [1] 91.50978 mean(filter(exp_summary_data, SELECTION_METHOD==&quot;lex&quot;)$avg_unique_selected) ## [1] 12.18061 mean(filter(exp_summary_data, SELECTION_METHOD==&quot;random&quot;)$avg_unique_selected) ## [1] 60.84774 8.8.1 Entropy of selected population IDs ggplot( exp_summary_data, aes( x=SELECTION_METHOD, y=avg_entropy_selected, fill=SELECTION_METHOD ) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8 ) + geom_point( mapping=aes(color=SELECTION_METHOD), position = position_jitter(height=0, width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_fill_fun( ) + scale_color_fun( ) + theme( legend.position=&quot;none&quot; ) 8.9 Average number of organisms in populations at end of maturation period ggplot( exp_summary_data, aes( x=SELECTION_METHOD, y=avg_num_orgs, fill=SELECTION_METHOD ) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8 ) + geom_point( mapping=aes(color=SELECTION_METHOD), position = position_jitter(width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_y_continuous( name=&quot;Average number of organisms&quot;, limits=c(950, 1000) ) + scale_x_discrete( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + scale_fill_fun( ) + scale_color_fun( ) + theme( legend.position=&quot;none&quot; ) ## Warning: Removed 1 rows containing non-finite values (stat_ydensity). ## Warning: Removed 1 rows containing non-finite values (stat_boxplot). ## Warning: Removed 1 rows containing missing values (geom_point). ggsave( paste0(plot_directory, &quot;2021-11-30-num-orgs.pdf&quot;) ) ## Saving 7 x 5 in image ## Warning: Removed 1 rows containing non-finite values (stat_ydensity). ## Warning: Removed 1 rows containing non-finite values (stat_boxplot). ## Warning: Removed 1 rows containing missing values (geom_point). 8.10 Average generations per maturation period ggplot( exp_summary_data, aes( x=SELECTION_METHOD, y=avg_gens, fill=SELECTION_METHOD ) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8 ) + geom_point( mapping=aes(color=SELECTION_METHOD), position = position_jitter(width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_y_continuous( name=&quot;Average generations per maturation period&quot; ) + scale_x_discrete( name=&quot;Selection Method&quot;, breaks=selection_method_breaks, labels=selection_method_labels ) + scale_fill_fun( ) + scale_color_fun( ) + theme( legend.position=&quot;none&quot; ) ggsave( paste0(plot_directory, &quot;2021-11-30-avg-gens.pdf&quot;) ) ## Saving 7 x 5 in image median(exp_summary_data$total_gens_approx) # Used for determining how many generations to run EC for ## [1] 65922.4 8.11 Manuscript figures Without time series: # NOTE - This is just a rough draft! grid &lt;- plot_grid( max_trait_cov_fig + theme( axis.title.x=element_blank(), axis.text.x = element_text(size = 9) ) + ggtitle(&quot;Best population task coverage&quot;), total_trait_cov_fig + theme( axis.title.x=element_blank(), axis.text.x = element_text(size = 9) ) + ggtitle(&quot;Metapopulation task coverage&quot;), num_pop_task_profiles_fig + theme( axis.text.x = element_text(size = 9) ) + ggtitle(&quot;Diversity of task profiles&quot;), task_profile_spread_fig + theme( axis.text.x = element_text(size = 9) ) + ggtitle(&quot;Spread of task profiles&quot;), nrow=2, ncol=2, labels=&quot;auto&quot; ) grid save_plot( filename=paste0(plot_directory, &quot;2021-11-30-selection-figure.pdf&quot;), plot=grid, base_height=6 ) With time series: legend &lt;- cowplot::get_legend( max_trait_cov_ot_fig + guides( color=guide_legend(nrow=1), fill=guide_legend(nrow=1) ) + theme( legend.position = &quot;bottom&quot;, legend.box=&quot;horizontal&quot;, legend.justification=&quot;center&quot; ) ) ## Warning: Computation failed in `stat_summary()`: max_trait_cov_row &lt;- plot_grid( max_trait_cov_ot_fig + ggtitle(&quot;Best population task coverage (over time)&quot;) + theme( legend.position=&quot;none&quot; # plot.title=element_text(size=12), # axis.text=element_text(size=10), # axis.text.x = element_text(size = 9), # axis.title.y = element_text(size = 10) ), max_trait_cov_fig + ggtitle(&quot;Best population task coverage (final)&quot;), theme( legend.position=&quot;none&quot; # plot.title=element_text(size=12), # axis.text=element_text(size=10), # axis.text.x = element_text(size = 9), # axis.title.y = element_text(size = 10) ), nrow=1, ncol=2, align=&quot;h&quot;, labels=c(&quot;a&quot;, &quot;b&quot;) # rel_widths=c(3,2), ) ## Warning: Computation failed in `stat_summary()`: ## Warning in as_grob.default(plot): Cannot convert object of class themegg into a ## grob. ## Warning: Graphs cannot be horizontally aligned unless the axis parameter is set. ## Placing graphs unaligned. max_trait_cov_row total_trait_cov_row &lt;- plot_grid( metapop_task_cov_ot_fig + ggtitle(&quot;Metapopulation task coverage (over time)&quot;) + theme( legend.position=&quot;none&quot; # plot.title=element_text(size=12), # axis.text=element_text(size=10), # axis.text.x = element_text(size = 9), # axis.title.y = element_text(size = 10) ), total_trait_cov_fig + ggtitle(&quot;Metapopulation task coverage (final)&quot;), theme( legend.position=&quot;none&quot; # plot.title=element_text(size=12), # axis.text=element_text(size=10), # axis.text.x = element_text(size = 9), # axis.title.y = element_text(size = 10) ), nrow=1, ncol=2, align=&quot;h&quot;, labels=c(&quot;c&quot;, &quot;d&quot;) # rel_widths=c(3,2), ) ## Warning: Computation failed in `stat_summary()`: ## Warning in as_grob.default(plot): Cannot convert object of class themegg into a ## grob. ## Warning: Graphs cannot be horizontally aligned unless the axis parameter is set. ## Placing graphs unaligned. total_trait_cov_row diversity_row &lt;- plot_grid( num_pop_task_profiles_fig + ggtitle(&quot;Diversity of task profiles&quot;) + theme( legend.position=&quot;none&quot; # plot.title=element_text(size=12), # axis.text=element_text(size=10), # axis.text.x = element_text(size = 9), # axis.title.y = element_text(size = 10) ), task_profile_spread_fig + ggtitle(&quot;Spread of task profiles&quot;), theme( legend.position=&quot;none&quot; # plot.title=element_text(size=12), # axis.text=element_text(size=10), # axis.text.x = element_text(size = 9), # axis.title.y = element_text(size = 10) ), nrow=1, ncol=2, align=&quot;h&quot;, labels=c(&quot;e&quot;, &quot;f&quot;) # rel_widths=c(3,2), ) ## Warning in as_grob.default(plot): Cannot convert object of class themegg into a ## grob. ## Warning in as_grob.default(plot): Graphs cannot be horizontally aligned unless ## the axis parameter is set. Placing graphs unaligned. # diversity_row grid &lt;- plot_grid( max_trait_cov_row, total_trait_cov_row, diversity_row, legend, nrow=4, ncol=1, rel_heights=c(1, 1, 1, 0.1) ) grid save_plot( filename=paste0(plot_directory, &quot;2021-11-30-aligned-tasks-figure-with-timeseries.pdf&quot;), plot=grid, base_width=12, base_height=10, # base_asp=1.6, dpi=600 ) "],["varying-population-maturation-period.html", "Chapter 9 Varying population maturation period 9.1 Overview 9.2 Analysis dependencies 9.3 Setup 9.4 Average number of organisms 9.5 Average generations elapsed during the maturation period 9.6 Total generations 9.7 Performance 9.8 Population-level Task Profile Diversity 9.9 Selection 9.10 Manuscript Figures 9.11 Discussion", " Chapter 9 Varying population maturation period 9.1 Overview How robust are our digital directed evolution results at different maturation periods? Adjusting the length of population maturation periods shifts the balance of individual-level and population-level selection pressure. Shorter maturation periods have shorter stints where organisms compete within a population between population-level selection events; whereas, longer maturation periods have longer stints where organisms are competing for space within a population before a population-level selection event occurs. Naively, we might maximize selection pressure on population-level functions by minimizing maturation periods; however, maturation periods of organism-level evolution are important for accumulating genetic variation in a population. We could maximize genetic divergence among populations in a metapopulation by using long maturation periods; however, if population-level selection events are too infrequent, there may not be sufficient selection pressure to maintain population-level functions if they are not also sufficiently beneficial at the individual-level. We expect there to be an ideal maturation period length that will vary depending on the particular organisms and functions being evolved. We ran a supplemental experiment to evaluate the robustness of our results at a range of maturation period lengths. For each of elite selection, lexicase selection, non-dominated elite selection, and no selection (control), we ran 50 replicates of digital directed evolution with the following maturation period lengths (given in updates): 20, 50, 100, 200 (the default used in our main experiments), 500, and 1,000. For each condition, we held the total number of updates constant (400,000 total updates); that is, we ran fewer overall cycles of directed evolution at larger maturation periods (e.g., 400 cycles for 1,000 update maturation periods), and a greater number of cycles at smaller maturation periods (e.g., 20,000 cycles for 20 update maturation periods). We used a more limited set of selection schemes for this supplemental experiment due to constraints on computing resources. experiment_slug &lt;- &quot;2021-11-12-time&quot; working_directory &lt;- paste0(&quot;experiments/&quot;,experiment_slug,&quot;/analysis/&quot;) 9.2 Analysis dependencies Load all required R libraries library(tidyverse) library(ggplot2) library(cowplot) library(RColorBrewer) library(scales) ## ## Attaching package: &#39;scales&#39; ## The following object is masked from &#39;package:purrr&#39;: ## ## discard ## The following object is masked from &#39;package:readr&#39;: ## ## col_factor library(khroma) source(&quot;https://gist.githubusercontent.com/benmarwick/2a1bb0133ff568cbe28d/raw/fb53bd97121f7f9ce947837ef1a4c65a73bffb3f/geom_flat_violin.R&quot;) These analyses were knit with the following environment: print(version) ## _ ## platform x86_64-pc-linux-gnu ## arch x86_64 ## os linux-gnu ## system x86_64, linux-gnu ## status ## major 4 ## minor 2.1 ## year 2022 ## month 06 ## day 23 ## svn rev 82513 ## language R ## version.string R version 4.2.1 (2022-06-23) ## nickname Funny-Looking Kid 9.3 Setup Experiment summary data exp_summary_data_loc &lt;- paste0(working_directory,&quot;data/experiment_summary.csv&quot;) exp_summary_data &lt;- read.csv(exp_summary_data_loc, na.strings=&quot;NONE&quot;) exp_summary_data$SELECTION_METHOD &lt;- factor( exp_summary_data$SELECTION_METHOD, levels=c( &quot;elite&quot;, &quot;tournament&quot;, &quot;lexicase&quot;, &quot;non-dominated-elite&quot;, &quot;non-dominated-tournament&quot;, &quot;random&quot;, &quot;none&quot; ), labels=c( &quot;elite&quot;, &quot;tourn&quot;, &quot;lex&quot;, &quot;nde&quot;, &quot;ndt&quot;, &quot;random&quot;, &quot;none&quot; ) ) exp_summary_data$UPDATES_PER_EPOCH &lt;- as.factor( exp_summary_data$UPDATES_PER_EPOCH ) exp_summary_data$TOURNAMENT_SEL_TOURN_SIZE &lt;- as.factor( exp_summary_data$TOURNAMENT_SEL_TOURN_SIZE ) exp_summary_data$U_PER_E &lt;- exp_summary_data$UPDATES_PER_EPOCH Miscellaneous setup # Configure our default graphing theme theme_set(theme_cowplot()) # Palette scale_fill_fun &lt;- scale_fill_bright scale_color_fun &lt;- scale_color_bright # Create a directory to store plots plot_directory &lt;- paste0(working_directory, &quot;plots/&quot;) dir.create(plot_directory, showWarnings=FALSE) selection_method_breaks &lt;- c(&quot;elite&quot;, &quot;tourn&quot;, &quot;lex&quot;, &quot;nde&quot;, &quot;random&quot;, &quot;none&quot;) selection_method_labels &lt;- c(&quot;ELITE&quot;, &quot;TOURN&quot;, &quot;LEX&quot;, &quot;NDE&quot;, &quot;RAND&quot;, &quot;NONE&quot;) exp_summary_data$SELECTION_METHOD_LABEL &lt;- factor( exp_summary_data$SELECTION_METHOD, levels=c( &quot;elite&quot;, &quot;tourn&quot;, &quot;lex&quot;, &quot;nde&quot;, &quot;ndt&quot;, &quot;random&quot;, &quot;none&quot; ), labels=c( &quot;Elite Selection&quot;, &quot;Tournament Selection&quot;, &quot;Lexicase Selection&quot;, &quot;Non-dominated Elite Selection&quot;, &quot;Non-dominated Tournament Selection&quot;, &quot;Random Selection&quot;, &quot;No Selection&quot; ) ) # 1, 4, 5, 7 selection_methods_smaller_set_colors &lt;- c(&quot;#4477AA&quot;, &quot;#CCBB44&quot;, &quot;#66CCEE&quot;, &quot;#BBBBBB&quot;) # c(&quot;#66C2A5&quot;, &quot;#E78AC3&quot;, &quot;#A6D854&quot;, &quot;#E5C494&quot;) # c(&quot;#66C2A5&quot;, &quot;#8DA0CB&quot;, &quot;#E78AC3&quot;, &quot;#FFD92F&quot;) 9.4 Average number of organisms Average number of organisms per world at the end of a run. ggplot( exp_summary_data, aes( x=U_PER_E, y=avg_num_orgs, fill=SELECTION_METHOD ) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8 ) + geom_point( mapping=aes(color=SELECTION_METHOD), position = position_jitter(width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_x_discrete( name=&quot;Maturation period (updates)&quot; ) + scale_fill_fun( ) + scale_color_fun( ) + facet_wrap( ~SELECTION_METHOD, scales=&quot;free_y&quot; ) + theme( legend.position=&quot;none&quot;, axis.text.x = element_text(size = 9, angle=-30, hjust=0) ) ggsave( paste0(plot_directory, &quot;avg_num_orgs.pdf&quot;) ) ## Saving 7 x 5 in image for (timing in levels(exp_summary_data$U_PER_E)) { for (sel in c(&quot;elite&quot;, &quot;lex&quot;, &quot;nde&quot;, &quot;none&quot;)) { print( paste( timing, sel, median(filter(exp_summary_data, U_PER_E==timing &amp; SELECTION_METHOD==sel)$avg_num_orgs) ) ) } print( paste( timing, &quot;overall&quot;, median(filter(exp_summary_data, U_PER_E==timing)$avg_num_orgs) ) ) } ## [1] &quot;20 elite 36.375&quot; ## [1] &quot;20 lex 32.5677083333333&quot; ## [1] &quot;20 nde 26.9739583333333&quot; ## [1] &quot;20 none 36.7239583333333&quot; ## [1] &quot;20 overall 34.5104166666667&quot; ## [1] &quot;50 elite 296.651041666667&quot; ## [1] &quot;50 lex 248.755208333333&quot; ## [1] &quot;50 nde 194.041666666667&quot; ## [1] &quot;50 none 295.171875&quot; ## [1] &quot;50 overall 276.234375&quot; ## [1] &quot;100 elite 948.760416666667&quot; ## [1] &quot;100 lex 902.833333333333&quot; ## [1] &quot;100 nde 898.255208333333&quot; ## [1] &quot;100 none 943.932291666667&quot; ## [1] &quot;100 overall 936.401041666667&quot; ## [1] &quot;200 elite 990.40625&quot; ## [1] &quot;200 lex 986.90625&quot; ## [1] &quot;200 nde 985.4375&quot; ## [1] &quot;200 none 992.286458333333&quot; ## [1] &quot;200 overall 989.020833333333&quot; ## [1] &quot;500 elite 990.322916666667&quot; ## [1] &quot;500 lex 988.875&quot; ## [1] &quot;500 nde 988.739583333333&quot; ## [1] &quot;500 none 993.416666666667&quot; ## [1] &quot;500 overall 990.192708333333&quot; ## [1] &quot;1000 elite 992.03125&quot; ## [1] &quot;1000 lex 990.921875&quot; ## [1] &quot;1000 nde 990.942708333333&quot; ## [1] &quot;1000 none 994.28125&quot; ## [1] &quot;1000 overall 992.28125&quot; ## [1] &quot;2000 elite 993.057291666667&quot; ## [1] &quot;2000 lex 992.255208333333&quot; ## [1] &quot;2000 nde 993.359375&quot; ## [1] &quot;2000 none 994.682291666667&quot; ## [1] &quot;2000 overall 994.026041666667&quot; 9.5 Average generations elapsed during the maturation period ggplot( exp_summary_data, aes( x=U_PER_E, y=avg_gens, fill=SELECTION_METHOD ) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8 ) + geom_point( mapping=aes(color=SELECTION_METHOD), position = position_jitter(width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_fill_manual( values=selection_methods_smaller_set_colors ) + scale_color_manual( values=selection_methods_smaller_set_colors ) + xlab(&quot;Updates per maturation period&quot;) + facet_wrap( ~SELECTION_METHOD_LABEL, scales=&quot;fixed&quot;, nrow=1 ) + theme( legend.position=&quot;none&quot;, axis.text.x = element_text(size = 9, angle=-30, hjust=0) ) ggsave( paste0(plot_directory, &quot;avg_gens_facet_sel.pdf&quot;), width=20, height=10 ) 9.6 Total generations ggplot( exp_summary_data, aes( x=U_PER_E, y=total_gens_approx, fill=SELECTION_METHOD ) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8 ) + geom_point( mapping=aes(color=SELECTION_METHOD), position = position_jitter(width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_x_discrete( name=&quot;Maturation period (updates)&quot; ) + scale_fill_manual( values=selection_methods_smaller_set_colors ) + scale_color_manual( values=selection_methods_smaller_set_colors ) + facet_wrap( ~SELECTION_METHOD, nrow=1 ) + theme( legend.position=&quot;none&quot;, axis.text.x = element_text(size = 9, angle=-30, hjust=0) ) ggsave( paste0(plot_directory, &quot;total_gens_approx.pdf&quot;), width=20, height=10 ) median(exp_summary_data$total_gens_approx) # Used for determining how many generations to run EC for ## [1] 57167.48 for (timing in levels(exp_summary_data$U_PER_E)) { for (sel in c(&quot;elite&quot;, &quot;lex&quot;, &quot;nde&quot;, &quot;none&quot;)) { print( paste( timing, sel, median(filter(exp_summary_data, U_PER_E==timing &amp; SELECTION_METHOD==sel)$total_gens_approx) ) ) } print( paste( timing, &quot;overall&quot;, median(filter(exp_summary_data, U_PER_E==timing)$total_gens_approx) ) ) } ## [1] &quot;20 elite 43147.1739335885&quot; ## [1] &quot;20 lex 40326.621331729&quot; ## [1] &quot;20 nde 34664.8985648439&quot; ## [1] &quot;20 none 42241.9147759426&quot; ## [1] &quot;20 overall 41329.1233619219&quot; ## [1] &quot;50 elite 55827.8934160416&quot; ## [1] &quot;50 lex 54050.7090498438&quot; ## [1] &quot;50 nde 52988.0677242188&quot; ## [1] &quot;50 none 53201.380141823&quot; ## [1] &quot;50 overall 53516.4253886458&quot; ## [1] &quot;100 elite 57213.4452847916&quot; ## [1] &quot;100 lex 55465.8904301564&quot; ## [1] &quot;100 nde 57919.3779984376&quot; ## [1] &quot;100 none 56054.7031978124&quot; ## [1] &quot;100 overall 56331.6952407812&quot; ## [1] &quot;200 elite 58024.9361635417&quot; ## [1] &quot;200 lex 56247.7024005208&quot; ## [1] &quot;200 nde 56511.7579942709&quot; ## [1] &quot;200 none 57294.2312760416&quot; ## [1] &quot;200 overall 57207.1385562501&quot; ## [1] &quot;500 elite 57585.15895625&quot; ## [1] &quot;500 lex 56747.8336604167&quot; ## [1] &quot;500 nde 57295.9740817708&quot; ## [1] &quot;500 none 58521.2714651041&quot; ## [1] &quot;500 overall 57697.65558125&quot; ## [1] &quot;1000 elite 58524.5463697916&quot; ## [1] &quot;1000 lex 58071.5926197917&quot; ## [1] &quot;1000 nde 58689.3264583334&quot; ## [1] &quot;1000 none 59456.0870677083&quot; ## [1] &quot;1000 overall 58907.1638229166&quot; ## [1] &quot;2000 elite 59469.05634375&quot; ## [1] &quot;2000 lex 59366.437359375&quot; ## [1] &quot;2000 nde 61755.465796875&quot; ## [1] &quot;2000 none 60074.0713125&quot; ## [1] &quot;2000 overall 60021.520203125&quot; 9.7 Performance 9.7.1 CPU cycles per replication ggplot( exp_summary_data, aes( x=U_PER_E, y=avg_cpu_cycles_per_replication, fill=SELECTION_METHOD ) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8 ) + geom_point( mapping=aes(color=SELECTION_METHOD), position = position_jitter(height=0, width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_x_discrete( name=&quot;Maturation period (updates)&quot; ) + scale_fill_manual( values=selection_methods_smaller_set_colors ) + scale_color_manual( values=selection_methods_smaller_set_colors ) + facet_wrap( ~SELECTION_METHOD, scales=&quot;fixed&quot;, nrow=1 ) + theme( legend.position=&quot;none&quot;, axis.text.x = element_text(size = 9, angle=-30, hjust=0) ) ggsave( paste0(plot_directory, &quot;avg_cpu_cycles_per_replication.pdf&quot;), width=20, height=10 ) 9.7.2 Best-population task coverage max_task_coverage_fig &lt;- ggplot( exp_summary_data, aes( x=U_PER_E, y=max_trait_coverage, fill=SELECTION_METHOD ) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8, adjust=1.5 ) + geom_point( mapping=aes(color=SELECTION_METHOD), position = position_jitter(height=0.1, width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_y_continuous( name=&quot;Task Coverage&quot;, limits=c(-0.5, 18.5), breaks=seq(0,18,2) ) + scale_x_discrete( name=&quot;Maturation period (updates)&quot; ) + scale_fill_manual( values=selection_methods_smaller_set_colors ) + scale_color_manual( values=selection_methods_smaller_set_colors ) + facet_wrap( ~SELECTION_METHOD_LABEL, scales=&quot;fixed&quot;, nrow=1 ) + theme( legend.position=&quot;none&quot;, axis.text.x = element_text(size = 9, angle=-30, hjust=0) ) max_task_coverage_fig ggsave( plot=max_task_coverage_fig, filename=paste0(plot_directory, &quot;max_trait_coverage.pdf&quot;), width=20, height=10 ) for (sel in c(&quot;elite&quot;, &quot;lex&quot;, &quot;nde&quot;, &quot;none&quot;)) { print(sel) sel_summary_data &lt;- filter(exp_summary_data, SELECTION_METHOD==sel) kt &lt;- kruskal.test( formula=max_trait_coverage~U_PER_E, data=sel_summary_data ) print(kt) if (kt$p.value &lt; 0.05) { pwt &lt;- pairwise.wilcox.test( x=sel_summary_data$max_trait_coverage, g=sel_summary_data$U_PER_E, p.adjust.method=&quot;bonferroni&quot;, ) print(pwt) } else { print(&quot;Not significant&quot;) } } ## [1] &quot;elite&quot; ## ## Kruskal-Wallis rank sum test ## ## data: max_trait_coverage by U_PER_E ## Kruskal-Wallis chi-squared = 79.646, df = 6, p-value = 4.228e-15 ## ## ## Pairwise comparisons using Wilcoxon rank sum test with continuity correction ## ## data: sel_summary_data$max_trait_coverage and sel_summary_data$U_PER_E ## ## 20 50 100 200 500 1000 ## 50 0.00055 - - - - - ## 100 1.00000 0.05140 - - - - ## 200 0.00218 4.0e-08 0.00091 - - - ## 500 0.00132 4.5e-10 0.00144 1.00000 - - ## 1000 0.31170 8.8e-08 0.11754 1.00000 1.00000 - ## 2000 0.79464 2.0e-07 0.31733 0.38852 0.87304 1.00000 ## ## P value adjustment method: bonferroni ## [1] &quot;lex&quot; ## ## Kruskal-Wallis rank sum test ## ## data: max_trait_coverage by U_PER_E ## Kruskal-Wallis chi-squared = 231.66, df = 6, p-value &lt; 2.2e-16 ## ## ## Pairwise comparisons using Wilcoxon rank sum test with continuity correction ## ## data: sel_summary_data$max_trait_coverage and sel_summary_data$U_PER_E ## ## 20 50 100 200 500 1000 ## 50 1.00000 - - - - - ## 100 4.2e-11 3.8e-10 - - - - ## 200 &lt; 2e-16 &lt; 2e-16 1.5e-08 - - - ## 500 &lt; 2e-16 4.1e-16 4.3e-07 1.00000 - - ## 1000 &lt; 2e-16 3.8e-16 5.3e-06 0.91939 1.00000 - ## 2000 2.3e-16 1.6e-15 0.07905 2.3e-05 0.00081 0.01194 ## ## P value adjustment method: bonferroni ## [1] &quot;nde&quot; ## ## Kruskal-Wallis rank sum test ## ## data: max_trait_coverage by U_PER_E ## Kruskal-Wallis chi-squared = 39.526, df = 6, p-value = 5.644e-07 ## ## ## Pairwise comparisons using Wilcoxon rank sum test with continuity correction ## ## data: sel_summary_data$max_trait_coverage and sel_summary_data$U_PER_E ## ## 20 50 100 200 500 1000 ## 50 0.37356 - - - - - ## 100 1.00000 0.00021 - - - - ## 200 1.00000 0.00023 1.00000 - - - ## 500 1.00000 0.00280 1.00000 1.00000 - - ## 1000 1.00000 0.00471 1.00000 1.00000 1.00000 - ## 2000 0.47187 9.1e-07 1.00000 1.00000 0.91202 0.05453 ## ## P value adjustment method: bonferroni ## [1] &quot;none&quot; ## ## Kruskal-Wallis rank sum test ## ## data: max_trait_coverage by U_PER_E ## Kruskal-Wallis chi-squared = 326.54, df = 6, p-value &lt; 2.2e-16 ## ## ## Pairwise comparisons using Wilcoxon rank sum test with continuity correction ## ## data: sel_summary_data$max_trait_coverage and sel_summary_data$U_PER_E ## ## 20 50 100 200 500 1000 ## 50 0.9092 - - - - - ## 100 &lt; 2e-16 &lt; 2e-16 - - - - ## 200 &lt; 2e-16 &lt; 2e-16 3.3e-15 - - - ## 500 &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 1.6e-12 - - ## 1000 &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 3.7e-16 4.5e-06 - ## 2000 &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 1.2e-13 0.0013 ## ## P value adjustment method: bonferroni 9.7.3 Metapopulation task coverage total_task_coverage_fig &lt;- ggplot( exp_summary_data, aes( x=U_PER_E, y=total_trait_coverage, fill=SELECTION_METHOD ) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8, adjust=1.5 ) + geom_point( mapping=aes(color=SELECTION_METHOD), position = position_jitter(height=0.1, width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_y_continuous( name=&quot;Task Coverage&quot;, limits=c(-0.5, 18.5), breaks=seq(0,18,2) ) + scale_x_discrete( name=&quot;Maturation period (updates)&quot; ) + scale_fill_manual( values=selection_methods_smaller_set_colors ) + scale_color_manual( values=selection_methods_smaller_set_colors ) + facet_wrap( ~SELECTION_METHOD_LABEL, scales=&quot;fixed&quot;, nrow=1 ) + theme( legend.position=&quot;none&quot;, axis.text.x = element_text(size = 9, angle=-30, hjust=0) ) total_task_coverage_fig ggsave( plot=total_task_coverage_fig, filename=paste0(plot_directory, &quot;total_trait_coverage.pdf&quot;), width=20, height=10 ) 9.8 Population-level Task Profile Diversity 9.8.1 Task profile richness ggplot( exp_summary_data, aes( x=U_PER_E, y=num_pop_trait_profiles, fill=SELECTION_METHOD ) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8, adjust=1.5 ) + geom_point( mapping=aes(color=SELECTION_METHOD), position = position_jitter(height=0.1, width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_fill_manual( values=selection_methods_smaller_set_colors ) + scale_color_manual( values=selection_methods_smaller_set_colors ) + xlab(&quot;Maturation period (updates)&quot;) + facet_wrap( ~SELECTION_METHOD, scales=&quot;fixed&quot;, nrow=1 ) + theme( legend.position=&quot;none&quot;, axis.text.x = element_text(size = 9, angle=-30, hjust=0) ) ggsave( paste0(plot_directory, &quot;num_pop_trait_profiles_facet_sel.pdf&quot;), width=20, height=10 ) 9.8.2 Task profile entropy ggplot( exp_summary_data, aes( x=U_PER_E, y=pop_trait_profile_entropy, fill=SELECTION_METHOD ) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8, adjust=1.5 ) + geom_point( mapping=aes(color=SELECTION_METHOD), position = position_jitter(width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_fill_manual( values=selection_methods_smaller_set_colors ) + scale_color_manual( values=selection_methods_smaller_set_colors ) + xlab(&quot;Maturation period (updates)&quot;) + facet_wrap( ~SELECTION_METHOD, scales=&quot;fixed&quot;, nrow=1 ) + theme( legend.position=&quot;none&quot;, axis.text.x = element_text(size = 9, angle=-30, hjust=0) ) ggsave( paste0(plot_directory, &quot;pop_trait_profile_entropy.pdf&quot;), width=20, height=10 ) 9.8.3 Spread (average cosine distance) ggplot( exp_summary_data, aes( x=U_PER_E, y=avg_cosine_dist_from_centroid, fill=SELECTION_METHOD ) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8, adjust=1.5 ) + geom_point( mapping=aes(color=SELECTION_METHOD), position = position_jitter(width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_fill_manual( values=selection_methods_smaller_set_colors ) + scale_color_manual( values=selection_methods_smaller_set_colors ) + xlab(&quot;Maturation period (updates)&quot;) + facet_wrap( ~SELECTION_METHOD, scales=&quot;fixed&quot;, nrow=1 ) + theme( legend.position=&quot;none&quot;, axis.text.x = element_text(size = 9, angle=-30, hjust=0) ) ## Warning: Removed 23 rows containing non-finite values (stat_ydensity). ## Warning: Removed 23 rows containing non-finite values (stat_boxplot). ## Warning: Removed 23 rows containing missing values (geom_point). ggsave( paste0(plot_directory, &quot;avg_cosine_dist_from_centroid_facet_sel.pdf&quot;), width=20, height=10 ) ## Warning: Removed 23 rows containing non-finite values (stat_ydensity). ## Warning: Removed 23 rows containing non-finite values (stat_boxplot). ## Warning: Removed 23 rows containing missing values (geom_point). 9.9 Selection 9.9.1 Average number of unique populations selected ggplot( exp_summary_data, aes( x=U_PER_E, y=avg_unique_selected, fill=SELECTION_METHOD ) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8 ) + geom_point( mapping=aes(color=SELECTION_METHOD), position = position_jitter(height=0, width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_x_discrete( name=&quot;Maturation period (updates)&quot; ) + scale_fill_manual( values=selection_methods_smaller_set_colors ) + scale_color_manual( values=selection_methods_smaller_set_colors ) + facet_wrap( ~SELECTION_METHOD, labeller=label_both, nrow=1 ) + theme( legend.position=&quot;none&quot;, axis.text.x = element_text(size = 9, angle=-30, hjust=0) ) ggsave( paste0(plot_directory, &quot;avg_unique_selected_facet_sel.pdf&quot;), width=20, height=10 ) 9.9.2 Average entropy of selection ids ggplot( exp_summary_data, aes( x=U_PER_E, y=avg_entropy_selected, fill=SELECTION_METHOD ) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8 ) + geom_point( mapping=aes(color=SELECTION_METHOD), position = position_jitter(height=0, width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_x_discrete( name=&quot;Maturation period (updates)&quot; ) + scale_fill_manual( values=selection_methods_smaller_set_colors ) + scale_color_manual( values=selection_methods_smaller_set_colors ) + facet_wrap( ~SELECTION_METHOD, scales=&quot;fixed&quot;, labeller=label_both ) + theme( legend.position=&quot;none&quot;, axis.text.x = element_text(size = 9, angle=-30, hjust=0) ) ggsave( paste0(plot_directory, &quot;avg_entropy_selected.pdf&quot;) ) ## Saving 7 x 5 in image 9.10 Manuscript Figures grid &lt;- plot_grid( max_task_coverage_fig + theme( axis.text.x = element_text(size = 9, angle=-30, hjust=0), strip.text.x = element_text(size = 10) ) + ggtitle(&quot;Best population task coverage&quot;), total_task_coverage_fig + theme( axis.text.x = element_text(size = 9, angle=-30, hjust=0), strip.text.x = element_text(size = 10) ) + ggtitle(&quot;Metapopulation task coverage&quot;), nrow=2, ncol=1, labels=&quot;auto&quot; ) grid save_plot( plot=grid, filename=paste0(plot_directory, &quot;2021-11-12-timing-figure.pdf&quot;), base_height=6 ) 9.11 Discussion Lengthening maturation period improves task coverage in the no selection control: there is more genetic variation that can build up between selection bottlenecks, which allows more population-level tasks to evolve by chance. Performance was surprisingly stable in elite and non-dominated elite selection. However, lengthening maturation period harms lexicase selections performance on metapopulation coverage. Overall, this experiment indicates that different selection schemes may respond differently to adjustments to the balance between individual-level and population-level selection, warranting further exploration in future work. "],["varied-genome-lengths.html", "Chapter 10 Varied genome lengths 10.1 Overview 10.2 Analysis dependencies 10.3 Setup 10.4 Average generations per maturation period 10.5 Total generations over experiment 10.6 Performance 10.7 Population-level task profile diversity 10.8 Selection 10.9 Discussion", " Chapter 10 Varied genome lengths 10.1 Overview In our main experiments, we limited genome length to 100 instructions. We ran a supplemental experiment to evaluate whether this limit substantially affected the directed evolution performance. Specifically, for each of elite and lexicase selection, we ran 30 replicates of digital directed evolution with the following genome length configurations: 50, 100 (default used in our main experiments), 150, and 200. Note that these runs were performed with a maturation period of 300 updates and run for a total of 3,000 cycles (instead of 200 and 2,000, respectively). experiment_slug &lt;- &quot;2021-11-08-longer-genomes&quot; working_directory &lt;- paste0(&quot;experiments/&quot;,experiment_slug,&quot;/analysis/&quot;) 10.2 Analysis dependencies Load all required R libraries library(tidyverse) library(ggplot2) library(cowplot) library(RColorBrewer) library(scales) library(khroma) source(&quot;https://gist.githubusercontent.com/benmarwick/2a1bb0133ff568cbe28d/raw/fb53bd97121f7f9ce947837ef1a4c65a73bffb3f/geom_flat_violin.R&quot;) These analyses were knit with the following environment: print(version) ## _ ## platform x86_64-pc-linux-gnu ## arch x86_64 ## os linux-gnu ## system x86_64, linux-gnu ## status ## major 4 ## minor 2.1 ## year 2022 ## month 06 ## day 23 ## svn rev 82513 ## language R ## version.string R version 4.2.1 (2022-06-23) ## nickname Funny-Looking Kid 10.3 Setup Experiment summary data exp_summary_data_loc &lt;- paste0(working_directory,&quot;data/experiment_summary.csv&quot;) exp_summary_data &lt;- read.csv(exp_summary_data_loc, na.strings=&quot;NONE&quot;) exp_summary_data$SELECTION_METHOD &lt;- factor( exp_summary_data$SELECTION_METHOD, levels=c( &quot;elite&quot;, &quot;tournament&quot;, &quot;lexicase&quot;, &quot;non-dominated-elite&quot;, &quot;non-dominated-tournament&quot;, &quot;random&quot;, &quot;none&quot; ), labels=c( &quot;elite&quot;, &quot;tourn&quot;, &quot;lex&quot;, &quot;nde&quot;, &quot;ndt&quot;, &quot;random&quot;, &quot;none&quot; ) ) exp_summary_data$AVIDAGP_ENV_FILE &lt;- factor( exp_summary_data$AVIDAGP_ENV_FILE, levels=c( &quot;environment-no-indiv.json&quot;, &quot;environment-big.json&quot; ), labels=c( &quot;env-bb-0&quot;, &quot;env-bb-1&quot; ) ) exp_summary_data$NUM_POPS &lt;- factor( exp_summary_data$NUM_POPS, levels=c( &quot;24&quot;, &quot;48&quot;, &quot;96&quot; ) ) exp_summary_data$UPDATES_PER_EPOCH &lt;- as.factor( exp_summary_data$UPDATES_PER_EPOCH ) exp_summary_data$TOURNAMENT_SEL_TOURN_SIZE &lt;- as.factor( exp_summary_data$TOURNAMENT_SEL_TOURN_SIZE ) exp_summary_data$POPULATION_SAMPLING_SIZE &lt;- as.factor( exp_summary_data$POPULATION_SAMPLING_SIZE ) exp_summary_data$genome_length &lt;- factor( exp_summary_data$ANCESTOR_FILE, levels=c( &quot;ancestor-50.gen&quot;, &quot;ancestor-100.gen&quot;, &quot;ancestor-150.gen&quot;, &quot;ancestor-200.gen&quot; ), labels=c( &quot;50&quot;, &quot;100&quot;, &quot;150&quot;, &quot;200&quot; ) ) exp_summary_data$SAMPLE_SIZE &lt;- exp_summary_data$POPULATION_SAMPLING_SIZE exp_summary_data$ENV &lt;- exp_summary_data$AVIDAGP_ENV_FILE exp_summary_data$U_PER_E &lt;- exp_summary_data$UPDATES_PER_EPOCH Miscellaneous setup # Configure our default graphing theme theme_set(theme_cowplot()) # Create a directory to store plots plot_directory &lt;- paste0(working_directory, &quot;plots/&quot;) dir.create(plot_directory, showWarnings=FALSE) selection_methods_smaller_set_colors &lt;- c(&quot;#4477AA&quot;, &quot;#CCBB44&quot;) 10.4 Average generations per maturation period ggplot( exp_summary_data, aes( x=genome_length, y=avg_gens, fill=SELECTION_METHOD ) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8 ) + geom_point( mapping=aes(color=SELECTION_METHOD), position = position_jitter(width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_fill_manual( values=selection_methods_smaller_set_colors ) + scale_color_manual( values=selection_methods_smaller_set_colors ) + facet_wrap( ~SELECTION_METHOD ) + theme( legend.position=&quot;none&quot;, panel.border=element_rect(colour=&quot;grey&quot;,size=1) ) ggsave( paste0(plot_directory, &quot;avg_gens.pdf&quot;), width=10, height=15 ) 10.5 Total generations over experiment ggplot( exp_summary_data, aes( x=genome_length, y=total_gens_approx, fill=SELECTION_METHOD ) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8 ) + geom_point( mapping=aes(color=SELECTION_METHOD), position = position_jitter(width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_fill_manual( values=selection_methods_smaller_set_colors ) + scale_color_manual( values=selection_methods_smaller_set_colors ) + facet_wrap( ~SELECTION_METHOD ) + theme( legend.position=&quot;none&quot;, panel.border=element_rect(colour=&quot;grey&quot;,size=1) ) ggsave( paste0(plot_directory, &quot;total_gens_approx.pdf&quot;), width=10, height=15 ) 10.6 Performance 10.6.1 CPU cycles per replication ggplot( exp_summary_data, aes( x=genome_length, y=avg_cpu_cycles_per_replication, fill=SELECTION_METHOD ) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8 ) + geom_point( mapping=aes(color=SELECTION_METHOD), position = position_jitter(height=0, width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_fill_manual( values=selection_methods_smaller_set_colors ) + scale_color_manual( values=selection_methods_smaller_set_colors ) + facet_wrap( ~SELECTION_METHOD ) + theme( legend.position=&quot;none&quot;, panel.border=element_rect(colour=&quot;grey&quot;,size=1) ) ggsave( paste0(plot_directory, &quot;avg_cpu_cycles_per_replication.pdf&quot;) ) ## Saving 7 x 5 in image 10.6.2 Best single-population task coverage ggplot( exp_summary_data, aes( x=genome_length, y=max_trait_coverage, fill=SELECTION_METHOD ) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8 ) + geom_point( mapping=aes(color=SELECTION_METHOD), position = position_jitter(height=0, width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_x_discrete( name=&quot;Genome length&quot; ) + scale_y_continuous( name=&quot;Task coverage&quot;, breaks=seq(0,18,2) ) + scale_fill_manual( values=selection_methods_smaller_set_colors ) + scale_color_manual( values=selection_methods_smaller_set_colors ) + facet_wrap( ~SELECTION_METHOD, nrow=1, labeller=label_both ) + theme( legend.position=&quot;none&quot;, panel.border=element_rect(colour=&quot;grey&quot;,size=1) ) ggsave( paste0(plot_directory, &quot;2021-11-08-best-pop-task-cov.pdf&quot;), width=8, height=4 ) 10.6.3 Metapopulation task coverage ggplot( exp_summary_data, aes( x=genome_length, y=total_trait_coverage, fill=SELECTION_METHOD ) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8 ) + geom_point( mapping=aes(color=SELECTION_METHOD), position = position_jitter(height=0, width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_x_discrete( name=&quot;Genome length&quot; ) + scale_y_continuous( name=&quot;Task coverage&quot;, breaks=seq(0,18,2) ) + scale_fill_manual( values=selection_methods_smaller_set_colors ) + scale_color_manual( values=selection_methods_smaller_set_colors ) + facet_wrap( ~SELECTION_METHOD, nrow=1, labeller=label_both ) + theme( legend.position=&quot;none&quot;, panel.border=element_rect(colour=&quot;grey&quot;,size=1) ) ggsave( paste0(plot_directory, &quot;2021-11-08-metapop-task-cov.pdf&quot;), width=8, height=4 ) 10.7 Population-level task profile diversity 10.7.1 Task profile richness ggplot( exp_summary_data, aes( x=genome_length, y=num_pop_trait_profiles, fill=SELECTION_METHOD ) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8 ) + geom_point( mapping=aes(color=SELECTION_METHOD), position = position_jitter(height=0, width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_fill_manual( values=selection_methods_smaller_set_colors ) + scale_color_manual( values=selection_methods_smaller_set_colors ) + facet_wrap( ~SELECTION_METHOD ) + theme( legend.position=&quot;none&quot;, panel.border=element_rect(colour=&quot;grey&quot;,size=1) ) ggsave( paste0(plot_directory, &quot;num_pop_trait_profiles.pdf&quot;) ) ## Saving 7 x 5 in image 10.7.2 Task profile entropy ggplot( exp_summary_data, aes( x=genome_length, y=pop_trait_profile_entropy, fill=SELECTION_METHOD ) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8 ) + geom_point( mapping=aes(color=SELECTION_METHOD), position = position_jitter(height=0, width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_fill_manual( values=selection_methods_smaller_set_colors ) + scale_color_manual( values=selection_methods_smaller_set_colors ) + facet_wrap( ~SELECTION_METHOD ) + theme( legend.position=&quot;none&quot;, panel.border=element_rect(colour=&quot;grey&quot;,size=1) ) ggsave( paste0(plot_directory, &quot;pop_trait_profile_entropy.pdf&quot;) ) ## Saving 7 x 5 in image 10.7.3 Spread (avg cosine distance) ggplot( exp_summary_data, aes( x=genome_length, y=avg_cosine_dist_from_centroid, fill=SELECTION_METHOD ) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8 ) + geom_point( mapping=aes(color=SELECTION_METHOD), position = position_jitter(height=0, width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_fill_manual( values=selection_methods_smaller_set_colors ) + scale_color_manual( values=selection_methods_smaller_set_colors ) + facet_wrap( ~SELECTION_METHOD ) + theme( legend.position=&quot;none&quot;, panel.border=element_rect(colour=&quot;grey&quot;,size=1) ) ggsave( paste0(plot_directory, &quot;avg_cosine_dist_from_centroid.pdf&quot;) ) ## Saving 7 x 5 in image 10.8 Selection 10.8.1 Average number of unique populations selected ggplot( exp_summary_data, aes( x=genome_length, y=avg_unique_selected, fill=SELECTION_METHOD ) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8 ) + geom_point( mapping=aes(color=SELECTION_METHOD), position = position_jitter(height=0, width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_fill_manual( values=selection_methods_smaller_set_colors ) + scale_color_manual( values=selection_methods_smaller_set_colors ) + facet_wrap( ~SELECTION_METHOD ) + theme( legend.position=&quot;none&quot;, panel.border=element_rect(colour=&quot;grey&quot;,size=1) ) ggsave( paste0(plot_directory, &quot;avg_unique_selected.pdf&quot;) ) ## Saving 7 x 5 in image 10.8.2 Average entropy of selection ids ggplot( exp_summary_data, aes( x=genome_length, y=avg_entropy_selected, fill=SELECTION_METHOD ) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8 ) + geom_point( mapping=aes(color=SELECTION_METHOD), position = position_jitter(height=0, width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_fill_manual( values=selection_methods_smaller_set_colors ) + scale_color_manual( values=selection_methods_smaller_set_colors ) + facet_wrap( ~SELECTION_METHOD ) + theme( legend.position=&quot;none&quot;, panel.border=element_rect(colour=&quot;grey&quot;,size=1) ) ggsave( paste0(plot_directory, &quot;avg_entropy_selected.pdf&quot;) ) ## Saving 7 x 5 in image 10.9 Discussion The task performance data show that our chosen genome length of 100 is a reasonable choice, as there are not substantial performance improvements with longer genome lengths. "],["population-propagule-sample-size.html", "Chapter 11 Population propagule sample size 11.1 Overview 11.2 Analysis dependencies 11.3 Setup 11.4 Average number of organisms 11.5 Average generations per maturation period 11.6 Performance", " Chapter 11 Population propagule sample size In this preliminary experiment, we looked at the effect of varying the size of propagules used when creating offspring populations from parent populations. We conducted these exploratory experiments well before the final set of experiments presented in our manuscript, so their setups are not the same: We only compared elite, lexicase, non-dominated elite, and a no selection control. The environment is simpler with 8 population-level functions instead of 18. The maximum population size is 900 instead of 1,000. The maturation period is longer (300 updates versus 200) We ran the experiment for fewer cycles (500 instead of 2,000). Overall, we found that the effect of propagule size varied by selection scheme. For elite selection and the no-selection control, sample size had little effect. For lexicase and non-dominated elite selection, the smallest propagule size (1% of the maximum population size) resulted in significantly better outcomes than using larger propagule sizes (e.g., 100% of the maximum population size). Because these data were collected during early experiments, we tracked fewer population/metapopulation statistics. Future work should further investigate the effects of propagule size, especially in the context of more complex environments that support more complex organism-organism interaction. 11.1 Overview experiment_slug &lt;- &quot;2021-09-30-sample-size&quot; working_directory &lt;- paste0(&quot;experiments/&quot;,experiment_slug,&quot;/analysis/&quot;) 11.2 Analysis dependencies Load all required R libraries library(tidyverse) library(ggplot2) library(cowplot) library(RColorBrewer) library(scales) library(khroma) source(&quot;https://gist.githubusercontent.com/benmarwick/2a1bb0133ff568cbe28d/raw/fb53bd97121f7f9ce947837ef1a4c65a73bffb3f/geom_flat_violin.R&quot;) These analyses were knit with the following environment: print(version) ## _ ## platform x86_64-pc-linux-gnu ## arch x86_64 ## os linux-gnu ## system x86_64, linux-gnu ## status ## major 4 ## minor 2.1 ## year 2022 ## month 06 ## day 23 ## svn rev 82513 ## language R ## version.string R version 4.2.1 (2022-06-23) ## nickname Funny-Looking Kid 11.3 Setup Experiment summary data exp_summary_data_loc &lt;- paste0(working_directory,&quot;data/experiment_summary.csv&quot;) exp_summary_data &lt;- read.csv(exp_summary_data_loc, na.strings=&quot;NONE&quot;) # Mark factors exp_summary_data$SELECTION_METHOD &lt;- factor( exp_summary_data$SELECTION_METHOD, levels=c( &quot;elite&quot;, &quot;tournament&quot;, &quot;lexicase&quot;, &quot;non-dominated-elite&quot;, &quot;non-dominated-tournament&quot;, &quot;random&quot;, &quot;none&quot; ), labels=c( &quot;elite&quot;, &quot;tournament&quot;, &quot;lex&quot;, &quot;nde&quot;, &quot;ndt&quot;, &quot;random&quot;, &quot;none&quot; ) ) exp_summary_data$NUM_POPS &lt;- factor( exp_summary_data$NUM_POPS, levels=c( &quot;24&quot;, &quot;48&quot;, &quot;96&quot; ) ) exp_summary_data$UPDATES_PER_EPOCH &lt;- as.factor( exp_summary_data$UPDATES_PER_EPOCH ) exp_summary_data$POPULATION_SAMPLING_SIZE &lt;- as.factor( exp_summary_data$POPULATION_SAMPLING_SIZE ) exp_summary_data$SAMPLE_SIZE &lt;- exp_summary_data$POPULATION_SAMPLING_SIZE exp_summary_data &lt;- filter(exp_summary_data, UPDATES_PER_EPOCH==&quot;300&quot;) Miscellaneous setup # Configure our default graphing theme theme_set(theme_cowplot()) # Create a directory to store plots plot_directory &lt;- paste0(working_directory, &quot;plots/&quot;) dir.create(plot_directory, showWarnings=FALSE) selection_methods_smaller_set_colors &lt;- c(&quot;#4477AA&quot;, &quot;#CCBB44&quot;, &quot;#66CCEE&quot;, &quot;#BBBBBB&quot;) sel.labs &lt;- c( &quot;elite&quot;, &quot;tournament&quot;, &quot;lex&quot;, &quot;nde&quot;, &quot;ndt&quot;, &quot;random&quot;, &quot;none&quot; ) names(sel.labs) &lt;- c( &quot;elite&quot;, &quot;tournament&quot;, &quot;lex&quot;, &quot;nde&quot;, &quot;ndt&quot;, &quot;random&quot;, &quot;none&quot; ) upe.labs &lt;- c( &quot;updates per cycle=100&quot;, &quot;updates per cycle=300&quot; ) names(upe.labs) &lt;- c( &quot;100&quot;, &quot;300&quot; ) 11.4 Average number of organisms Average number of organisms per world at the end of a run. ggplot( exp_summary_data, aes( x=POPULATION_SAMPLING_SIZE, y=avg_num_orgs, fill=SELECTION_METHOD ) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8 ) + geom_point( mapping=aes(color=SELECTION_METHOD), position = position_jitter(width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_fill_manual( values=selection_methods_smaller_set_colors ) + scale_color_manual( values=selection_methods_smaller_set_colors ) + facet_grid( UPDATES_PER_EPOCH~SELECTION_METHOD, labeller = labeller(UPDATES_PER_EPOCH=upe.labs, SELECTION_METHOD=sel.labs) ) + theme( legend.position=&quot;none&quot;, axis.text.x=element_text(angle=45,hjust=1) ) ggsave( paste0(plot_directory, &quot;avg_num_orgs.pdf&quot;) ) ## Saving 7 x 5 in image In general, the smaller propagule sizes are less likely to reach 900 organisms during the maturation period. However, all final population sizes are within 25 organisms of each, so no substantial differences here. 11.5 Average generations per maturation period ggplot( exp_summary_data, aes( x=POPULATION_SAMPLING_SIZE, y=avg_gens, fill=SELECTION_METHOD ) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8 ) + geom_point( mapping=aes(color=SELECTION_METHOD), position = position_jitter(width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_fill_manual( values=selection_methods_smaller_set_colors ) + scale_color_manual( values=selection_methods_smaller_set_colors ) + facet_grid( UPDATES_PER_EPOCH~SELECTION_METHOD, labeller = labeller(UPDATES_PER_EPOCH=upe.labs, SELECTION_METHOD=sel.labs) ) + theme( legend.position=&quot;none&quot;, axis.text.x=element_text(angle=45,hjust=1) ) ggsave( paste0(plot_directory, &quot;avg_gens.pdf&quot;), width=10, height=15 ) 11.6 Performance 11.6.1 Best population task coverage ggplot( exp_summary_data, aes( x=POPULATION_SAMPLING_SIZE, y=max_trait_coverage, fill=SELECTION_METHOD ) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8 ) + geom_point( mapping=aes(color=SELECTION_METHOD), position = position_jitter(width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_y_continuous( name=&quot;Task Coverage&quot; ) + scale_fill_manual( values=selection_methods_smaller_set_colors ) + scale_color_manual( values=selection_methods_smaller_set_colors ) + facet_grid( UPDATES_PER_EPOCH~SELECTION_METHOD, labeller = labeller(UPDATES_PER_EPOCH=upe.labs, SELECTION_METHOD=sel.labs) ) + ggtitle(&quot;Best population task coverage&quot;) + theme( legend.position=&quot;none&quot;, axis.text.x=element_text(angle=45,hjust=1), panel.border=element_rect(colour=&quot;grey&quot;,size=1) ) ggsave( paste0(plot_directory, &quot;max_trait_coverage.png&quot;), width=10, height=6 ) comp_data &lt;- filter( exp_summary_data, SELECTION_METHOD==&quot;lex&quot; ) kruskal.test( formula=max_trait_coverage~POPULATION_SAMPLING_SIZE, data=comp_data ) ## ## Kruskal-Wallis rank sum test ## ## data: max_trait_coverage by POPULATION_SAMPLING_SIZE ## Kruskal-Wallis chi-squared = 69.574, df = 3, p-value = 5.266e-15 pairwise.wilcox.test( x=comp_data$max_trait_coverage, g=comp_data$POPULATION_SAMPLING_SIZE, p.adjust.method=&quot;bonferroni&quot;, exact=FALSE ) ## ## Pairwise comparisons using Wilcoxon rank sum test with continuity correction ## ## data: comp_data$max_trait_coverage and comp_data$POPULATION_SAMPLING_SIZE ## ## 9 90 450 ## 90 5.8e-09 - - ## 450 1.1e-10 0.091 - ## 900 1.6e-10 0.241 1.000 ## ## P value adjustment method: bonferroni 11.6.2 Metapopulation task coverage ggplot( exp_summary_data, aes( x=POPULATION_SAMPLING_SIZE, y=total_trait_coverage, fill=SELECTION_METHOD ) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8 ) + geom_point( mapping=aes(color=SELECTION_METHOD), position = position_jitter(width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_y_continuous( name=&quot;Task Coverage&quot; ) + scale_fill_manual( values=selection_methods_smaller_set_colors ) + scale_color_manual( values=selection_methods_smaller_set_colors ) + facet_grid( UPDATES_PER_EPOCH~SELECTION_METHOD, labeller = labeller(UPDATES_PER_EPOCH=upe.labs, SELECTION_METHOD=sel.labs) ) + ggtitle(&quot;Metapopulation task coverage&quot;) + theme( legend.position=&quot;none&quot;, axis.text.x=element_text(angle=45,hjust=1), panel.border=element_rect(colour=&quot;grey&quot;,size=1) ) ggsave( paste0(plot_directory, &quot;total_trait_coverage.png&quot;), width=10, height=6 ) comp_data &lt;- filter( exp_summary_data, SELECTION_METHOD==&quot;lex&quot; ) kruskal.test( formula=total_trait_coverage~POPULATION_SAMPLING_SIZE, data=comp_data ) ## ## Kruskal-Wallis rank sum test ## ## data: total_trait_coverage by POPULATION_SAMPLING_SIZE ## Kruskal-Wallis chi-squared = 74.497, df = 3, p-value = 4.644e-16 pairwise.wilcox.test( x=comp_data$total_trait_coverage, g=comp_data$POPULATION_SAMPLING_SIZE, p.adjust.method=&quot;bonferroni&quot;, exact=FALSE ) ## ## Pairwise comparisons using Wilcoxon rank sum test with continuity correction ## ## data: comp_data$total_trait_coverage and comp_data$POPULATION_SAMPLING_SIZE ## ## 9 90 450 ## 90 2.2e-09 - - ## 450 2.3e-11 0.0012 - ## 900 5.3e-11 0.0279 1.0000 ## ## P value adjustment method: bonferroni "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
